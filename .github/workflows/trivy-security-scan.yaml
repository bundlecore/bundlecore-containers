name: Trivy Security Scan

on:
  schedule:
    # Run every Sunday at 2:00 AM UTC
    - cron: "0 2 * * 0"
  workflow_dispatch:
    # Allow manual triggering of the workflow
    inputs:
      debug_mode:
        description: "Enable debug mode for troubleshooting"
        required: false
        default: false
        type: boolean

permissions:
  contents: read # Required for checkout action
  packages: read # Required to access GitHub Container Registry
  security-events: write # Required to upload SARIF results to Security tab
  actions: read # Required for workflow access
  pull-requests: read # Sometimes needed for full access

jobs:
  security-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Discover container images
        id: discover-images
        run: |
          echo "Discovering container images to scan..."

          # Create output file for discovered images
          IMAGES_FILE="images_to_scan.txt"
          > "$IMAGES_FILE"

          # Get organization name from repository
          ORG_NAME="${GITHUB_REPOSITORY_OWNER}"
          echo "Scanning packages for organization: $ORG_NAME"

          # Debug information
          echo ""
          echo "üîç Environment Debug Information:"
          echo "================================="
          echo "  ‚Üí Repository: ${GITHUB_REPOSITORY}"
          echo "  ‚Üí Owner: ${GITHUB_REPOSITORY_OWNER}"
          echo "  ‚Üí Actor: ${GITHUB_ACTOR}"
          echo "  ‚Üí Token available: $([ -n "${{ secrets.GITHUB_TOKEN }}" ] && echo "Yes" || echo "No")"
          echo "  ‚Üí Workflow permissions: packages:read, security-events:write, contents:read"
          echo ""

          # Determine which token to use
          if [ -n "${{ secrets.PACKAGES_TOKEN }}" ]; then
            echo "üîë Using PACKAGES_TOKEN (Personal Access Token)"
            AUTH_TOKEN="${{ secrets.PACKAGES_TOKEN }}"
          else
            echo "üîë Using GITHUB_TOKEN (default)"
            AUTH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          fi

          # Test basic API access first
          echo "üîß Testing GitHub API Access:"
          echo "=============================="
          echo "‚Üí Testing basic API connectivity..."

          # Test with a simple API call that should always work
          if curl -s -f -H "Authorization: Bearer $AUTH_TOKEN" \
                    -H "Accept: application/vnd.github.v3+json" \
                    "https://api.github.com/user" > /dev/null; then
            echo "‚úì Basic API access successful"
          else
            echo "‚úó Basic API access failed"
            echo "  ‚Üí Token may be invalid or have insufficient permissions"
            echo ""
            echo "üí° Solutions to try:"
            echo "  1. Check repository Settings ‚Üí Actions ‚Üí General ‚Üí Workflow permissions"
            echo "  2. Ensure 'Read and write permissions' is selected"
            echo "  3. Or create a Personal Access Token with 'packages:read' scope"
            echo "  4. Add it as PACKAGES_TOKEN secret in repository settings"
            echo ""
            echo "üîç Current token info:"
            echo "  ‚Üí Using: $([ -n "${{ secrets.PACKAGES_TOKEN }}" ] && echo "PACKAGES_TOKEN (PAT)" || echo "GITHUB_TOKEN (default)")"
            echo "  ‚Üí Repository: ${GITHUB_REPOSITORY}"
            echo "  ‚Üí Actor: ${GITHUB_ACTOR}"
            exit 1
          fi

          # Function to make API calls with retry logic and rate limit optimization
          make_api_call() {
            local url="$1"
            local max_retries=3
            local retry_delay=5
            local attempt=1
            
            while [ $attempt -le $max_retries ]; do
              echo "  ‚Üí API call attempt $attempt/$max_retries: $url" >&2
              
              # Make the API call with timeout and proper error handling
              local response
              local http_code
              
              response=$(curl -s -w "%{http_code}" \
                             --max-time 30 \
                             --retry 0 \
                             -H "Authorization: Bearer $AUTH_TOKEN" \
                             -H "Accept: application/vnd.github.v3+json" \
                             "$url")
              http_code="${response: -3}"
              response="${response%???}"
              
              case "$http_code" in
                200)
                  echo "  ‚úì API call successful (HTTP $http_code)" >&2
                  printf "%s" "$response"
                  return 0
                  ;;
                401)
                  echo "  ‚úó Authentication failed (HTTP $http_code)" >&2
                  return 1
                  ;;
                403)
                  echo "  ‚úó Access forbidden (HTTP $http_code)" >&2
                  return 1
                  ;;
                404)
                  echo "  ‚úó Resource not found (HTTP $http_code)" >&2
                  return 1
                  ;;
                429)
                  echo "  ‚ö† Rate limit exceeded (HTTP $http_code)" >&2
                  if [ $attempt -lt $max_retries ]; then
                    local backoff_delay=$((retry_delay * attempt * 2 + RANDOM % 10))
                    echo "    ‚Üí Rate limit backoff: waiting ${backoff_delay}s before retry..." >&2
                    sleep $backoff_delay
                  fi
                  ;;
                5*)
                  echo "  ‚ö† Server error (HTTP $http_code)" >&2
                  if [ $attempt -lt $max_retries ]; then
                    echo "    ‚Üí Retrying in ${retry_delay}s..." >&2
                    sleep $retry_delay
                  fi
                  ;;
                *)
                  echo "  ‚úó Unexpected response (HTTP $http_code)" >&2
                  if [ $attempt -lt $max_retries ]; then
                    echo "    ‚Üí Retrying in ${retry_delay}s..." >&2
                    sleep $retry_delay
                  fi
                  ;;
              esac
              
              attempt=$((attempt + 1))
            done
            
            echo "  ‚úó API call failed after $max_retries attempts" >&2
            return 1
          }

          # Try organization endpoint first, then user endpoint if that fails
          echo "Fetching container packages from GitHub API..."

          # Try organization endpoint first
          echo "‚Üí Attempting organization endpoint..."
          ORG_URL="https://api.github.com/orgs/${ORG_NAME}/packages?package_type=container&per_page=100"

          set +e
          PACKAGES_RESPONSE=$(make_api_call "$ORG_URL")
          ORG_EXIT_CODE=$?
          set -e

          if [ $ORG_EXIT_CODE -eq 0 ] && [ -n "$PACKAGES_RESPONSE" ]; then
            echo "‚úì Organization endpoint successful"
          else
            echo "‚úó Organization endpoint failed, trying user endpoint..."
            USER_URL="https://api.github.com/users/${ORG_NAME}/packages?package_type=container&per_page=100"
            
            set +e
            PACKAGES_RESPONSE=$(make_api_call "$USER_URL")
            USER_EXIT_CODE=$?
            set -e
            
            if [ $USER_EXIT_CODE -eq 0 ] && [ -n "$PACKAGES_RESPONSE" ]; then
              echo "‚úì User endpoint successful"
            else
              echo "‚úó Both endpoints failed"
              exit 1
            fi
          fi

          # Validate API response
          if [ -z "$PACKAGES_RESPONSE" ]; then
            echo "‚úó Empty response from GitHub API"
            exit 1
          fi

          # Validate JSON response format
          TEMP_JSON=$(mktemp)
          printf "%s" "$PACKAGES_RESPONSE" > "$TEMP_JSON"

          if ! jq empty "$TEMP_JSON" 2>/dev/null; then
            echo "‚úó Invalid JSON response from GitHub API"
            rm -f "$TEMP_JSON"
            exit 1
          fi

          # Extract and filter packages for products/bfx/* only
          ALL_PACKAGES_COUNT=$(jq '. | length' "$TEMP_JSON")
          echo "üì¶ Package Discovery Results:"
          echo "============================="
          echo "  ‚Üí Total packages found: $ALL_PACKAGES_COUNT"

          # Get all package names and filter for products/bfx/*
          ALL_PACKAGE_NAMES=$(jq -r '.[].name' "$TEMP_JSON")
          BFX_PACKAGES=$(echo "$ALL_PACKAGE_NAMES" | grep "^products/bfx/" || true)
          BFX_COUNT=$(echo "$BFX_PACKAGES" | grep -c . 2>/dev/null || echo "0")

          echo "  ‚Üí products/bfx/* packages found: $BFX_COUNT"

          if [ "$BFX_COUNT" -eq 0 ]; then
            echo "    ‚ùå No products/bfx/* packages found"
            echo ""
            echo "üîç All package names for debugging:"
            echo "$ALL_PACKAGE_NAMES" | head -10 | sed 's/^/    - /'
            rm -f "$TEMP_JSON"
            exit 1
          fi

          echo "$BFX_PACKAGES" | sed 's/^/    ‚úì /'
          rm -f "$TEMP_JSON"

          # Process each package to get versions/tags
          TOTAL_PACKAGES=$BFX_COUNT
          PACKAGE_COUNT=0

          echo ""
          echo "üöÄ Processing $TOTAL_PACKAGES products/bfx/* packages..."
          echo ""

          echo "$BFX_PACKAGES" | while read -r package_name; do
            if [ -n "$package_name" ]; then
              PACKAGE_COUNT=$((PACKAGE_COUNT + 1))
              echo "[$PACKAGE_COUNT/$TOTAL_PACKAGES] Processing: $package_name"
              
              # Rate limiting
              if [ $PACKAGE_COUNT -gt 1 ]; then
                sleep 1
              fi
              
              # URL encode the package name
              encoded_package_name=$(echo "$package_name" | sed 's|/|%2F|g')
              
              # Get versions for this package
              VERSIONS_URL="https://api.github.com/orgs/${ORG_NAME}/packages/container/${encoded_package_name}/versions?per_page=100"
              VERSIONS_RESPONSE=$(make_api_call "$VERSIONS_URL")
              
              if [ $? -ne 0 ] || [ -z "$VERSIONS_RESPONSE" ]; then
                VERSIONS_URL="https://api.github.com/users/${ORG_NAME}/packages/container/${encoded_package_name}/versions?per_page=100"
                VERSIONS_RESPONSE=$(make_api_call "$VERSIONS_URL")
              fi
              
              if [ $? -eq 0 ] && [ -n "$VERSIONS_RESPONSE" ]; then
                # Validate versions response
                if echo "$VERSIONS_RESPONSE" | jq empty 2>/dev/null && echo "$VERSIONS_RESPONSE" | jq -e 'type == "array"' >/dev/null 2>&1; then
                  VERSION_COUNT=$(echo "$VERSIONS_RESPONSE" | jq '. | length')
                  echo "  ‚Üí Found $VERSION_COUNT versions for package"
                  
                  # Extract tags and create image URLs
                  echo "$VERSIONS_RESPONSE" | jq -r '.[].metadata.container.tags[]?' | while read -r tag; do
                    if [ -n "$tag" ] && [[ ! "$tag" == *.sig ]] && [[ ! "$tag" == sha256-* ]] && [[ "$tag" =~ ^[a-zA-Z0-9._:-]+$ ]]; then
                      image_url="ghcr.io/${ORG_NAME}/${package_name}:${tag}"
                      echo "$image_url" >> "$IMAGES_FILE"
                      echo "    ‚úì Found image: $image_url"
                    fi
                  done
                fi
              else
                echo "  ‚úó Failed to fetch versions for package $package_name"
              fi
            fi
          done

          # Display summary
          if [ -f "$IMAGES_FILE" ] && [ -s "$IMAGES_FILE" ]; then
            IMAGE_COUNT=$(wc -l < "$IMAGES_FILE")
            echo ""
            echo "‚úì Discovery complete. Found $IMAGE_COUNT images to scan:"
            cat "$IMAGES_FILE"
            
            echo "images-file=$IMAGES_FILE" >> $GITHUB_OUTPUT
            echo "image-count=$IMAGE_COUNT" >> $GITHUB_OUTPUT
          else
            echo ""
            echo "‚ö† No images found to scan"
            echo "images-file=" >> $GITHUB_OUTPUT
            echo "image-count=0" >> $GITHUB_OUTPUT
          fi

      - name: Upload discovered images list
        if: steps.discover-images.outputs.image-count > 0
        uses: actions/upload-artifact@v4
        with:
          name: discovered-images
          path: ${{ steps.discover-images.outputs.images-file }}
          retention-days: 7

    outputs:
      image-count: ${{ steps.discover-images.outputs.image-count }}
      images-file: ${{ steps.discover-images.outputs.images-file }}

  trivy-scan:
    name: Trivy Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 120
    needs: security-scan
    if: needs.security-scan.outputs.image-count > 0

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Trivy database cache
        uses: actions/cache@v4
        with:
          path: ~/.cache/trivy
          key: trivy-db-${{ runner.os }}-${{ github.run_id }}
          restore-keys: |
            trivy-db-${{ runner.os }}-
            trivy-db-

      - name: Download discovered images list
        uses: actions/download-artifact@v4
        with:
          name: discovered-images

      - name: Pre-warm Trivy database cache
        run: |
          echo "Pre-warming Trivy database cache..."
          mkdir -p ~/.cache/trivy

          docker run --rm \
            -v "$HOME/.cache/trivy:/root/.cache/trivy" \
            -e TRIVY_CACHE_DIR="/root/.cache/trivy" \
            aquasec/trivy:latest image --download-db-only

          echo "‚úì Trivy database cache pre-warmed"

      - name: Batch scan images with Trivy
        id: batch-scan
        timeout-minutes: 90
        run: |
          IMAGES_FILE="images_to_scan.txt"
          SCAN_COUNT=0
          SUCCESS_COUNT=0
          FAILURE_COUNT=0
          TOTAL_IMAGES=$(wc -l < "$IMAGES_FILE")

          echo "Starting batch scan of $TOTAL_IMAGES images using Trivy..."

          # Set up results directory
          mkdir -p trivy-results

          # Process each image
          while IFS= read -r image_url; do
            if [ -n "$image_url" ]; then
              SCAN_COUNT=$((SCAN_COUNT + 1))
              echo "[$SCAN_COUNT/$TOTAL_IMAGES] Processing: $image_url"
              
              # Create safe filename for outputs
              SAFE_NAME=$(echo "$image_url" | sed 's|[^a-zA-Z0-9._-]|_|g')
              SARIF_FILE="trivy-results/trivy-${SAFE_NAME}.sarif"
              
              # Attempt Trivy scan
              if timeout 15m docker run --rm \
                --memory=2g \
                --cpus=2 \
                -v "$(pwd)/trivy-results:/output" \
                -v "$HOME/.cache/trivy:/root/.cache/trivy" \
                -e TRIVY_USERNAME="${{ github.actor }}" \
                -e TRIVY_PASSWORD="${{ secrets.GITHUB_TOKEN }}" \
                -e TRIVY_CACHE_DIR="/root/.cache/trivy" \
                aquasec/trivy:latest image \
                --format sarif \
                --severity CRITICAL,HIGH \
                --timeout 12m \
                --exit-code 0 \
                --skip-update \
                --output "/output/trivy-${SAFE_NAME}.sarif" \
                "$image_url" 2>/dev/null; then
                
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                echo "  ‚úì Scan completed successfully"
                
                if [ -f "$SARIF_FILE" ]; then
                  VULN_COUNT=$(jq -r '.runs[0].results | length' "$SARIF_FILE" 2>/dev/null || echo "0")
                  echo "  ‚Üí Found $VULN_COUNT vulnerabilities (CRITICAL/HIGH)"
                fi
              else
                FAILURE_COUNT=$((FAILURE_COUNT + 1))
                echo "  ‚úó Scan failed - continuing with next image"
              fi
              
              echo ""
            fi
          done < "$IMAGES_FILE"

          echo "Batch Scan Summary"
          echo "=================="
          echo "Total images processed: $SCAN_COUNT"
          echo "Successful scans: $SUCCESS_COUNT"
          echo "Failed scans: $FAILURE_COUNT"

          echo "total-scanned=$SCAN_COUNT" >> $GITHUB_OUTPUT
          echo "successful-scans=$SUCCESS_COUNT" >> $GITHUB_OUTPUT
          echo "failed-scans=$FAILURE_COUNT" >> $GITHUB_OUTPUT

          if [ $SUCCESS_COUNT -gt 0 ]; then
            echo "‚úì Batch scan completed with $SUCCESS_COUNT successful scans"
            exit 0
          else
            echo "‚úó All scans failed"
            exit 1
          fi

      - name: Prepare SARIF files for upload
        if: steps.batch-scan.outputs.successful-scans > 0
        id: prepare-sarif
        run: |
          echo "Preparing SARIF files for GitHub Security upload..."

          SARIF_COUNT=0
          # Count SARIF files
          for sarif_file in trivy-results/*.sarif; do
            if [ -f "$sarif_file" ]; then
              SARIF_COUNT=$((SARIF_COUNT + 1))
            fi
          done

          if [ "$SARIF_COUNT" -eq 0 ]; then
            echo "No SARIF files found to upload"
            echo "sarif-count=0" >> $GITHUB_OUTPUT
          else
            echo "Found $SARIF_COUNT SARIF files to upload"
            echo "sarif-count=$SARIF_COUNT" >> $GITHUB_OUTPUT
          fi

      - name: Upload SARIF results to GitHub Security
        if: steps.prepare-sarif.outputs.sarif-count > 0
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-results/
          category: trivy-container-security-scan
          checkout_path: ${{ github.workspace }}
          wait-for-processing: true
        continue-on-error: false

      - name: Upload scan results as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: trivy-scan-results
          path: trivy-results/
          retention-days: 30

    outputs:
      total-scanned: ${{ steps.batch-scan.outputs.total-scanned }}
      successful-scans: ${{ steps.batch-scan.outputs.successful-scans }}
      failed-scans: ${{ steps.batch-scan.outputs.failed-scans }}

  summary:
    name: Scan Summary
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [security-scan, trivy-scan]
    if: always()

    steps:
      - name: Download scan results for summary
        if: needs.trivy-scan.result != 'skipped'
        uses: actions/download-artifact@v4
        with:
          name: trivy-scan-results
          path: scan-results/
        continue-on-error: true

      - name: Display comprehensive scan summary
        run: |
          echo "Trivy Security Scan Workflow Complete"
          echo "======================================"
          echo "Workflow execution time: $(date)"
          echo ""

          # Discovery phase summary
          echo "üìã Discovery Phase:"
          if [ "${{ needs.security-scan.outputs.image-count }}" -gt 0 ]; then
            echo "  ‚úì Images discovered: ${{ needs.security-scan.outputs.image-count }}"
          else
            echo "  ‚ö† No container images found to scan"
            echo "    ‚Üí Verify images are published to ghcr.io with products/bfx/ prefix"
            echo "    ‚Üí Check repository permissions for package access"
          fi
          echo ""

          # Scanning phase summary
          echo "üîç Scanning Phase:"
          case "${{ needs.trivy-scan.result }}" in
            "success")
              echo "  ‚úì Batch scanning completed successfully"
              echo "  üìÅ Results Location:"
              echo "    ‚Üí GitHub Security tab: ${{ github.server_url }}/${{ github.repository }}/security"
              echo "    ‚Üí Code Scanning Alerts: ${{ github.server_url }}/${{ github.repository }}/security/code-scanning"
              echo "    ‚Üí Filter by category: 'trivy-container-security-scan'"
              ;;
            "failure")
              echo "  ‚úó Batch scanning encountered issues"
              echo "    ‚Üí Check individual scan logs in workflow details"
              ;;
            "skipped")
              echo "  ‚è≠ Scanning was skipped (no images to process)"
              ;;
            *)
              echo "  ‚ùì Scanning status: ${{ needs.trivy-scan.result }}"
              ;;
          esac
          echo ""

          # Next steps
          echo "ÔøΩ Nnext Steps:"
          if [ "${{ needs.trivy-scan.result }}" == "success" ]; then
            echo "  1. Navigate to GitHub Security tab to review uploaded SARIF results"
            echo "  2. Filter code scanning alerts by 'trivy-container-security-scan' category"
            echo "  3. Review CRITICAL and HIGH severity vulnerabilities by image"
            echo "  4. Track remediation progress using GitHub Security features"
          elif [ "${{ needs.security-scan.outputs.image-count }}" -eq 0 ]; then
            echo "  1. Verify container images are published to ghcr.io"
            echo "  2. Check that images follow the products/bfx/* naming pattern"
            echo "  3. Ensure workflow has proper permissions to access packages"
          else
            echo "  1. Review workflow logs for specific error details"
            echo "  2. Check network connectivity and registry access"
            echo "  3. Verify Trivy configuration and image accessibility"
          fi

          echo ""
          echo "üîÑ This workflow runs automatically every Sunday at 2:00 AM UTC"
          echo "   Manual execution: Use 'Run workflow' button in Actions tab"
