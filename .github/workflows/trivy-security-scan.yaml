name: Trivy Security Scan

on:
  schedule:
    # Run on the first Sunday of every month at 2:00 AM UTC
    - cron: "0 2 1-7 * 0"
  workflow_dispatch:
    # Allow manual triggering of the workflow
    inputs:
      debug_mode:
        description: "Enable debug mode for troubleshooting"
        required: false
        default: false
        type: boolean
      force_fresh_scan:
        description: "Force fresh scan even if recent results are available"
        required: false
        default: false
        type: boolean
      disable_recent_check:
        description: "Disable recent scan checking (always do fresh scan)"
        required: false
        default: false
        type: boolean
      resume_from_progress:
        description: "Resume from previous scan progress (if available)"
        required: false
        default: true
        type: boolean
      skip_to_organize:
        description: "Skip scanning and go directly to organize results (if scan results exist)"
        required: false
        default: false
        type: boolean

permissions:
  contents: write # Required for creating files and PRs
  packages: read # Required to access GitHub Container Registry
  pull-requests: write # Required to create pull requests
  actions: read # Required for workflow access

jobs:
  check-recent-scans:
    name: Check Recent Scan Results
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for recent successful scans
        id: check-recent
        run: |
          echo "Checking for recent successful scan results..."

          # Get recent workflow runs for this workflow
          WORKFLOW_NAME="Trivy Security Scan"
          ONE_WEEK_AGO=$(date -u -d '1 week ago' +%Y-%m-%dT%H:%M:%SZ)

          echo "Looking for successful runs since: $ONE_WEEK_AGO"

          # Check if user disabled recent scan checking or forced a fresh scan
          if [ "${{ github.event.inputs.disable_recent_check }}" == "true" ]; then
            echo "🔄 Recent scan checking disabled - will skip recent results check"
            echo "recent-scan-available=false" >> $GITHUB_OUTPUT
            echo "recent-run-id=" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "${{ github.event.inputs.force_fresh_scan }}" == "true" ]; then
            echo "🔄 Force fresh scan requested - will skip recent results check"
            echo "recent-scan-available=false" >> $GITHUB_OUTPUT
            echo "recent-run-id=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get recent workflow runs using GitHub API (without date filter first)
          echo "Fetching recent workflow runs..."
          RECENT_RUNS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs?status=completed&per_page=20")

          # Debug: Show what we got
          echo "API Response status: $(echo "$RECENT_RUNS" | jq -r '.total_count // "unknown"') total runs"

          # Check if we have any successful runs with our workflow name
          RECENT_SUCCESS_COUNT=$(echo "$RECENT_RUNS" | jq -r --arg workflow_name "$WORKFLOW_NAME" '.workflow_runs[]? | select(.name == $workflow_name and .conclusion == "success") | .id' | wc -l)

          echo "Found $RECENT_SUCCESS_COUNT successful runs with workflow name: $WORKFLOW_NAME"

          if [ "$RECENT_SUCCESS_COUNT" -gt 0 ]; then
            # Get the most recent successful run
            LATEST_RUN_ID=$(echo "$RECENT_RUNS" | jq -r --arg workflow_name "$WORKFLOW_NAME" '.workflow_runs[]? | select(.name == $workflow_name and .conclusion == "success") | .id' | head -1)
            LATEST_RUN_DATE=$(echo "$RECENT_RUNS" | jq -r --arg run_id "$LATEST_RUN_ID" '.workflow_runs[]? | select(.id == ($run_id | tonumber)) | .created_at')
            
            # Check if the run is recent enough (within 1 week)
            RUN_TIMESTAMP=$(date -d "$LATEST_RUN_DATE" +%s 2>/dev/null || echo "0")
            WEEK_AGO_TIMESTAMP=$(date -d '1 week ago' +%s)
            
            if [ "$RUN_TIMESTAMP" -gt "$WEEK_AGO_TIMESTAMP" ]; then
              echo "✓ Found recent successful scan:"
              echo "  → Run ID: $LATEST_RUN_ID"
              echo "  → Date: $LATEST_RUN_DATE"
              echo "  → URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/$LATEST_RUN_ID"
              
              echo "recent-scan-available=true" >> $GITHUB_OUTPUT
              echo "recent-run-id=$LATEST_RUN_ID" >> $GITHUB_OUTPUT
            else
              echo "⚠ Most recent successful scan is too old (older than 1 week)"
              echo "  → Run date: $LATEST_RUN_DATE"
              echo "  → Will proceed with fresh scan"
              echo "recent-scan-available=false" >> $GITHUB_OUTPUT
              echo "recent-run-id=" >> $GITHUB_OUTPUT
            fi
          else
            echo "⚠ No recent successful scans found"
            echo "  → Will proceed with fresh scan"
            
            # Debug: Show available workflows
            echo "Available recent workflows:"
            echo "$RECENT_RUNS" | jq -r '.workflow_runs[]? | "  - \(.name) (\(.conclusion)) - \(.created_at)"' | head -5
            
            echo "recent-scan-available=false" >> $GITHUB_OUTPUT
            echo "recent-run-id=" >> $GITHUB_OUTPUT
          fi

    outputs:
      recent-scan-available: ${{ steps.check-recent.outputs.recent-scan-available }}
      recent-run-id: ${{ steps.check-recent.outputs.recent-run-id }}

  security-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: check-recent-scans
    if: always() # Run even if check-recent-scans is skipped

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Discover container images
        id: discover-images
        run: |
          echo "Discovering container images to scan..."

          # Create output file for discovered images
          IMAGES_FILE="images_to_scan.txt"
          > "$IMAGES_FILE"

          # Get organization name from repository
          ORG_NAME="${GITHUB_REPOSITORY_OWNER}"
          echo "Scanning packages for organization: $ORG_NAME"

          # Debug information
          echo ""
          echo "🔍 Environment Debug Information:"
          echo "================================="
          echo "  → Repository: ${GITHUB_REPOSITORY}"
          echo "  → Owner: ${GITHUB_REPOSITORY_OWNER}"
          echo "  → Actor: ${GITHUB_ACTOR}"
          echo "  → Token available: $([ -n "${{ secrets.GITHUB_TOKEN }}" ] && echo "Yes" || echo "No")"
          echo "  → Workflow permissions: packages:read, contents:write, pull-requests:write"
          echo ""

          # Determine which token to use
          if [ -n "${{ secrets.PACKAGES_TOKEN }}" ]; then
            echo "🔑 Using PACKAGES_TOKEN (Personal Access Token)"
            AUTH_TOKEN="${{ secrets.PACKAGES_TOKEN }}"
          else
            echo "🔑 Using GITHUB_TOKEN (default)"
            AUTH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          fi

          # Function to make API calls with retry logic
          make_api_call() {
            local url="$1"
            local max_retries=3
            local retry_delay=5
            local attempt=1
            
            while [ $attempt -le $max_retries ]; do
              echo "  → API call attempt $attempt/$max_retries: $url" >&2
              
              local response
              local http_code
              
              response=$(curl -s -w "%{http_code}" \
                             --max-time 30 \
                             --retry 0 \
                             -H "Authorization: Bearer $AUTH_TOKEN" \
                             -H "Accept: application/vnd.github.v3+json" \
                             "$url")
              http_code="${response: -3}"
              response="${response%???}"
              
              case "$http_code" in
                200)
                  echo "  ✓ API call successful (HTTP $http_code)" >&2
                  printf "%s" "$response"
                  return 0
                  ;;
                401|403|404)
                  echo "  ✗ API call failed (HTTP $http_code)" >&2
                  return 1
                  ;;
                429)
                  echo "  ⚠ Rate limit exceeded (HTTP $http_code)" >&2
                  if [ $attempt -lt $max_retries ]; then
                    local backoff_delay=$((retry_delay * attempt * 2))
                    echo "    → Rate limit backoff: waiting ${backoff_delay}s..." >&2
                    sleep $backoff_delay
                  fi
                  ;;
                5*)
                  echo "  ⚠ Server error (HTTP $http_code)" >&2
                  if [ $attempt -lt $max_retries ]; then
                    echo "    → Retrying in ${retry_delay}s..." >&2
                    sleep $retry_delay
                  fi
                  ;;
              esac
              
              attempt=$((attempt + 1))
            done
            
            echo "  ✗ API call failed after $max_retries attempts" >&2
            return 1
          }

          # Try organization endpoint first, then user endpoint if that fails
          echo "Fetching container packages from GitHub API..."

          ORG_URL="https://api.github.com/orgs/${ORG_NAME}/packages?package_type=container&per_page=100"
          set +e
          PACKAGES_RESPONSE=$(make_api_call "$ORG_URL")
          ORG_EXIT_CODE=$?
          set -e

          if [ $ORG_EXIT_CODE -eq 0 ] && [ -n "$PACKAGES_RESPONSE" ]; then
            echo "✓ Organization endpoint successful"
          else
            echo "✗ Organization endpoint failed, trying user endpoint..."
            USER_URL="https://api.github.com/users/${ORG_NAME}/packages?package_type=container&per_page=100"
            
            set +e
            PACKAGES_RESPONSE=$(make_api_call "$USER_URL")
            USER_EXIT_CODE=$?
            set -e
            
            if [ $USER_EXIT_CODE -eq 0 ] && [ -n "$PACKAGES_RESPONSE" ]; then
              echo "✓ User endpoint successful"
            else
              echo "✗ Both endpoints failed"
              exit 1
            fi
          fi

          # Validate and process packages
          if [ -z "$PACKAGES_RESPONSE" ]; then
            echo "✗ Empty response from GitHub API"
            exit 1
          fi

          TEMP_JSON=$(mktemp)
          printf "%s" "$PACKAGES_RESPONSE" > "$TEMP_JSON"

          if ! jq empty "$TEMP_JSON" 2>/dev/null; then
            echo "✗ Invalid JSON response from GitHub API"
            rm -f "$TEMP_JSON"
            exit 1
          fi

          # Extract and filter packages for products/bfx/* only
          ALL_PACKAGES_COUNT=$(jq '. | length' "$TEMP_JSON")
          echo "📦 Package Discovery Results:"
          echo "============================="
          echo "  → Total packages found: $ALL_PACKAGES_COUNT"

          # Get all package names and filter for products/bfx/*
          ALL_PACKAGE_NAMES=$(jq -r '.[].name' "$TEMP_JSON")
          BFX_PACKAGES=$(echo "$ALL_PACKAGE_NAMES" | grep "^products/bfx/" || true)
          BFX_COUNT=$(echo "$BFX_PACKAGES" | grep -c . 2>/dev/null || echo "0")

          echo "  → products/bfx/* packages found: $BFX_COUNT"

          if [ "$BFX_COUNT" -eq 0 ]; then
            echo "    ❌ No products/bfx/* packages found"
            rm -f "$TEMP_JSON"
            exit 1
          fi

          echo "$BFX_PACKAGES" | sed 's/^/    ✓ /'
          rm -f "$TEMP_JSON"

          # Process each package to get versions/tags and group by tool
          echo ""
          echo "🚀 Processing $BFX_COUNT products/bfx/* packages..."
          echo ""

          # Create a mapping file for tool -> images
          TOOL_IMAGES_FILE="tool_images_mapping.json"
          echo "{}" > "$TOOL_IMAGES_FILE"

          echo "$BFX_PACKAGES" | while read -r package_name; do
            if [ -n "$package_name" ]; then
              # Extract tool name from package (products/bfx/toolname -> toolname)
              TOOL_NAME=$(echo "$package_name" | sed 's|products/bfx/||')
              echo "Processing tool: $TOOL_NAME"
              
              # URL encode the package name
              encoded_package_name=$(echo "$package_name" | sed 's|/|%2F|g')
              
              # Get versions for this package
              VERSIONS_URL="https://api.github.com/orgs/${ORG_NAME}/packages/container/${encoded_package_name}/versions?per_page=100"
              VERSIONS_RESPONSE=$(make_api_call "$VERSIONS_URL")
              
              if [ $? -ne 0 ] || [ -z "$VERSIONS_RESPONSE" ]; then
                VERSIONS_URL="https://api.github.com/users/${ORG_NAME}/packages/container/${encoded_package_name}/versions?per_page=100"
                VERSIONS_RESPONSE=$(make_api_call "$VERSIONS_URL")
              fi
              
              if [ $? -eq 0 ] && [ -n "$VERSIONS_RESPONSE" ]; then
                # Validate versions response and extract tags
                if echo "$VERSIONS_RESPONSE" | jq empty 2>/dev/null && echo "$VERSIONS_RESPONSE" | jq -e 'type == "array"' >/dev/null 2>&1; then
                  VERSION_COUNT=$(echo "$VERSIONS_RESPONSE" | jq '. | length')
                  echo "  → Found $VERSION_COUNT versions for $TOOL_NAME"
                  
                  # Extract tags and create image URLs, add to tool mapping
                  echo "$VERSIONS_RESPONSE" | jq -r '.[].metadata.container.tags[]?' | while read -r tag; do
                    if [ -n "$tag" ] && [[ ! "$tag" == *.sig ]] && [[ ! "$tag" == sha256-* ]] && [[ "$tag" =~ ^[a-zA-Z0-9._:-]+$ ]]; then
                      image_url="ghcr.io/${ORG_NAME}/${package_name}:${tag}"
                      echo "$image_url" >> "$IMAGES_FILE"
                      
                      # Add to tool mapping
                      jq --arg tool "$TOOL_NAME" --arg image "$image_url" --arg tag "$tag" \
                        '.[$tool] = (.[$tool] // []) + [{"image": $image, "tag": $tag}]' \
                        "$TOOL_IMAGES_FILE" > "${TOOL_IMAGES_FILE}.tmp" && mv "${TOOL_IMAGES_FILE}.tmp" "$TOOL_IMAGES_FILE"
                      
                      echo "    ✓ Added: $image_url"
                    fi
                  done
                fi
              else
                echo "  ✗ Failed to fetch versions for $TOOL_NAME"
              fi
            fi
          done

          # Display summary
          if [ -f "$IMAGES_FILE" ] && [ -s "$IMAGES_FILE" ]; then
            IMAGE_COUNT=$(wc -l < "$IMAGES_FILE")
            echo ""
            echo "✓ Discovery complete. Found $IMAGE_COUNT images to scan"
            
            echo "images-file=$IMAGES_FILE" >> $GITHUB_OUTPUT
            echo "image-count=$IMAGE_COUNT" >> $GITHUB_OUTPUT
            echo "tool-mapping-file=$TOOL_IMAGES_FILE" >> $GITHUB_OUTPUT
          else
            echo ""
            echo "⚠ No images found to scan"
            echo "images-file=" >> $GITHUB_OUTPUT
            echo "image-count=0" >> $GITHUB_OUTPUT
            echo "tool-mapping-file=" >> $GITHUB_OUTPUT
          fi

      - name: Upload discovered images and mapping
        if: steps.discover-images.outputs.image-count > 0
        uses: actions/upload-artifact@v4
        with:
          name: discovered-images
          path: |
            ${{ steps.discover-images.outputs.images-file }}
            ${{ steps.discover-images.outputs.tool-mapping-file }}
          retention-days: 7

    outputs:
      image-count: ${{ steps.discover-images.outputs.image-count }}
      images-file: ${{ steps.discover-images.outputs.images-file }}
      tool-mapping-file: ${{ steps.discover-images.outputs.tool-mapping-file }}

  trivy-scan:
    name: Trivy Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 180
    needs: [check-recent-scans, security-scan]
    if: needs.security-scan.outputs.image-count > 0

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Trivy database cache
        uses: actions/cache@v4
        with:
          path: ~/.cache/trivy
          key: trivy-db-${{ runner.os }}-${{ github.run_id }}
          restore-keys: |
            trivy-db-${{ runner.os }}-
            trivy-db-

      - name: Download discovered images and mapping
        uses: actions/download-artifact@v4
        with:
          name: discovered-images

      - name: Download previous scan progress
        uses: actions/download-artifact@v4
        with:
          name: scan-progress
          path: .
        continue-on-error: true

      - name: Debug progress files
        run: |
          echo "Checking for progress files after download..."
          ls -la scan_progress.txt completed_scans.txt failed_scans.txt 2>/dev/null || echo "Progress files not found"

          if [ -f "completed_scans.txt" ]; then
            echo "Found completed_scans.txt with $(wc -l < completed_scans.txt) entries"
            echo "First few completed scans:"
            head -5 completed_scans.txt
          else
            echo "No completed_scans.txt found"
          fi

      - name: Check for recent scan results to reuse
        id: check-reuse
        if: needs.check-recent-scans.outputs.recent-scan-available == 'true' && github.event.inputs.force_fresh_scan != 'true'
        run: |
          echo "Attempting to download recent scan results..."

          RECENT_RUN_ID="${{ needs.check-recent-scans.outputs.recent-run-id }}"
          echo "Checking artifacts from run: $RECENT_RUN_ID"

          if command -v gh >/dev/null 2>&1; then
            echo "Using GitHub CLI to download artifacts..."
            if gh run download "$RECENT_RUN_ID" --name "trivy-scan-results" --dir recent-results 2>/dev/null; then
              echo "✓ Successfully downloaded recent scan results"
              echo "reuse-available=true" >> $GITHUB_OUTPUT
              
              if [ -d "recent-results" ] && find recent-results -name "*.json" -type f | head -1 >/dev/null; then
                JSON_COUNT=$(find recent-results -name "*.json" -type f | wc -l)
                echo "  → Found $JSON_COUNT JSON files in recent results"
                echo "json-count=$JSON_COUNT" >> $GITHUB_OUTPUT
              else
                echo "⚠ No JSON files found in recent results"
                echo "reuse-available=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "⚠ Failed to download recent scan results"
              echo "reuse-available=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "⚠ GitHub CLI not available, cannot download recent artifacts"
            echo "reuse-available=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Pre-warm Trivy database cache
        if: steps.check-reuse.outputs.reuse-available != 'true' || github.event.inputs.force_fresh_scan == 'true'
        run: |
          echo "Pre-warming Trivy database cache..."
          mkdir -p ~/.cache/trivy

          docker run --rm \
            -v "$HOME/.cache/trivy:/root/.cache/trivy" \
            -e TRIVY_CACHE_DIR="/root/.cache/trivy" \
            aquasec/trivy:latest image --download-db-only

          echo "✓ Trivy database cache pre-warmed"

      - name: Check for existing scan progress
        id: check-progress
        if: steps.check-reuse.outputs.reuse-available != 'true' || github.event.inputs.force_fresh_scan == 'true'
        run: |
          echo "Checking for existing scan progress..."

          IMAGES_FILE="images_to_scan.txt"
          PROGRESS_FILE="scan_progress.txt"
          COMPLETED_FILE="completed_scans.txt"

          # Create progress tracking files
          touch "$PROGRESS_FILE"
          touch "$COMPLETED_FILE"

          # Check if user wants to resume from progress
          if [ "${{ github.event.inputs.resume_from_progress }}" != "true" ]; then
            echo "🔄 Resume from progress disabled - starting fresh scan"
            > "$COMPLETED_FILE"  # Clear completed file
            > "$PROGRESS_FILE"   # Clear progress file
          fi

          # Also check if there are existing scan results in the current workspace
          if [ ! -s "$COMPLETED_FILE" ] && [ -d "trivy-results" ]; then
            echo "🔍 Checking for existing scan results in current workspace..."
            EXISTING_RESULTS=$(find trivy-results -name "trivy-*.json" -type f | wc -l)
            if [ "$EXISTING_RESULTS" -gt 0 ]; then
              echo "  → Found $EXISTING_RESULTS existing scan result files"
              echo "  → Extracting image URLs from existing results..."
              
              # Extract image URLs from existing JSON files and add to completed list
              for json_file in trivy-results/trivy-*.json; do
                if [ -f "$json_file" ]; then
                  # Try to extract image URL from metadata or filename
                  IMAGE_URL=$(jq -r '.Metadata.ImageID // empty' "$json_file" 2>/dev/null || true)
                  if [ -z "$IMAGE_URL" ]; then
                    # Fallback: reconstruct from filename
                    SAFE_NAME=$(basename "$json_file" .json | sed 's/^trivy-//')
                    # This is a rough reconstruction - may not be perfect
                    echo "  ⚠ Could not extract image URL from $json_file"
                  else
                    echo "$IMAGE_URL" >> "$COMPLETED_FILE"
                    echo "  ✓ Added existing result: $IMAGE_URL"
                  fi
                fi
              done
              
              if [ -s "$COMPLETED_FILE" ]; then
                RECOVERED_COUNT=$(wc -l < "$COMPLETED_FILE")
                echo "  → Recovered $RECOVERED_COUNT completed scans from existing results"
              fi
            fi
          fi

          TOTAL_IMAGES=$(wc -l < "$IMAGES_FILE")
          COMPLETED_COUNT=0

          if [ -s "$COMPLETED_FILE" ]; then
            COMPLETED_COUNT=$(wc -l < "$COMPLETED_FILE")
            echo "📋 Found existing scan progress:"
            echo "  → Total images: $TOTAL_IMAGES"
            echo "  → Already completed: $COMPLETED_COUNT"
            echo "  → Remaining: $((TOTAL_IMAGES - COMPLETED_COUNT))"
            
            # Create list of remaining images to scan
            REMAINING_FILE="remaining_to_scan.txt"
            comm -23 <(sort "$IMAGES_FILE") <(sort "$COMPLETED_FILE") > "$REMAINING_FILE"
            
            echo "resume-scan=true" >> $GITHUB_OUTPUT
            echo "remaining-file=$REMAINING_FILE" >> $GITHUB_OUTPUT
            echo "completed-count=$COMPLETED_COUNT" >> $GITHUB_OUTPUT
          else
            echo "📋 No existing progress found - starting fresh scan"
            echo "  → Total images to scan: $TOTAL_IMAGES"
            
            echo "resume-scan=false" >> $GITHUB_OUTPUT
            echo "remaining-file=$IMAGES_FILE" >> $GITHUB_OUTPUT
            echo "completed-count=0" >> $GITHUB_OUTPUT
          fi

      - name: Batch scan images with Trivy
        id: batch-scan
        timeout-minutes: 150
        if: (steps.check-reuse.outputs.reuse-available != 'true' || github.event.inputs.force_fresh_scan == 'true') && github.event.inputs.skip_to_organize != 'true'
        run: |
          IMAGES_FILE="${{ steps.check-progress.outputs.remaining-file }}"
          PROGRESS_FILE="scan_progress.txt"
          COMPLETED_FILE="completed_scans.txt"
          FAILED_FILE="failed_scans.txt"

          SCAN_COUNT=0
          SUCCESS_COUNT=${{ steps.check-progress.outputs.completed-count }}
          FAILURE_COUNT=0
          TOTAL_IMAGES=$(wc -l < "images_to_scan.txt")
          REMAINING_IMAGES=$(wc -l < "$IMAGES_FILE")

          if [ "${{ steps.check-progress.outputs.resume-scan }}" == "true" ]; then
            echo "🔄 Resuming batch scan from previous progress..."
            echo "  → Already completed: $SUCCESS_COUNT images"
            echo "  → Remaining to scan: $REMAINING_IMAGES images"
          else
            echo "🚀 Starting fresh batch scan of $TOTAL_IMAGES images using Trivy..."
          fi

          # Log why we're doing a fresh scan
          if [ "${{ github.event.inputs.force_fresh_scan }}" == "true" ]; then
            echo "🔄 Performing fresh scan (forced by user input)"
          elif [ "${{ needs.check-recent-scans.outputs.recent-scan-available }}" == "true" ]; then
            echo "🔄 Performing fresh scan (recent results not usable)"
          else
            echo "🔄 Performing fresh scan (no recent results available)"
          fi
          echo ""

          # Set up results directory
          mkdir -p trivy-results

          # Process each image with progress tracking
          while IFS= read -r image_url; do
            if [ -n "$image_url" ]; then
              SCAN_COUNT=$((SCAN_COUNT + 1))
              CURRENT_TOTAL=$((SUCCESS_COUNT + SCAN_COUNT))
              echo "[$CURRENT_TOTAL/$TOTAL_IMAGES] Processing: $image_url"
              
              # Check if this image was already scanned successfully
              if grep -Fxq "$image_url" "$COMPLETED_FILE" 2>/dev/null; then
                echo "  ⏭ Already scanned - skipping"
                continue
              fi
              
              # Create safe filename for outputs
              SAFE_NAME=$(echo "$image_url" | sed 's|[^a-zA-Z0-9._-]|_|g')
              JSON_FILE="trivy-results/trivy-${SAFE_NAME}.json"
              
              # Record scan attempt
              echo "$(date -u +%Y-%m-%dT%H:%M:%SZ) SCANNING $image_url" >> "$PROGRESS_FILE"
              
              # Attempt Trivy scan with JSON output
              if timeout 15m docker run --rm \
                --memory=2g \
                --cpus=2 \
                -v "$(pwd)/trivy-results:/output" \
                -v "$HOME/.cache/trivy:/root/.cache/trivy" \
                -e TRIVY_USERNAME="${{ github.actor }}" \
                -e TRIVY_PASSWORD="${{ secrets.GITHUB_TOKEN }}" \
                -e TRIVY_CACHE_DIR="/root/.cache/trivy" \
                aquasec/trivy:latest image \
                --format json \
                --severity CRITICAL,HIGH \
                --timeout 12m \
                --exit-code 0 \
                --skip-update \
                --output "/output/trivy-${SAFE_NAME}.json" \
                "$image_url" 2>/dev/null; then
                
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                echo "  ✓ Scan completed successfully"
                
                # Record successful completion
                echo "$image_url" >> "$COMPLETED_FILE"
                echo "$(date -u +%Y-%m-%dT%H:%M:%SZ) SUCCESS $image_url" >> "$PROGRESS_FILE"
                
                if [ -f "$JSON_FILE" ]; then
                  VULN_COUNT=$(jq -r '.Results[]?.Vulnerabilities // [] | length' "$JSON_FILE" 2>/dev/null | awk '{sum+=$1} END {print sum+0}')
                  echo "  → Found $VULN_COUNT vulnerabilities (CRITICAL/HIGH)"
                fi
                
                # Save progress every 5 successful scans
                if [ $((SUCCESS_COUNT % 5)) -eq 0 ]; then
                  echo "  💾 Progress checkpoint: $SUCCESS_COUNT/$TOTAL_IMAGES completed"
                fi
              else
                FAILURE_COUNT=$((FAILURE_COUNT + 1))
                echo "  ✗ Scan failed - continuing with next image"
                
                # Record failure
                echo "$image_url" >> "$FAILED_FILE"
                echo "$(date -u +%Y-%m-%dT%H:%M:%SZ) FAILED $image_url" >> "$PROGRESS_FILE"
              fi
              
              echo ""
            fi
          done < "$IMAGES_FILE"

          echo ""
          echo "Batch Scan Summary"
          echo "=================="
          echo "Total images in queue: $TOTAL_IMAGES"
          echo "Images processed this run: $SCAN_COUNT"
          echo "Total successful scans: $SUCCESS_COUNT"
          echo "Failed scans this run: $FAILURE_COUNT"

          # Calculate completion percentage
          if [ $TOTAL_IMAGES -gt 0 ]; then
            COMPLETION_PCT=$(( SUCCESS_COUNT * 100 / TOTAL_IMAGES ))
            echo "Overall completion: $SUCCESS_COUNT/$TOTAL_IMAGES ($COMPLETION_PCT%)"
          fi

          # Show progress file info
          if [ -f "$PROGRESS_FILE" ]; then
            echo "Progress log entries: $(wc -l < "$PROGRESS_FILE")"
          fi

          if [ -f "$FAILED_FILE" ]; then
            FAILED_TOTAL=$(wc -l < "$FAILED_FILE")
            if [ $FAILED_TOTAL -gt 0 ]; then
              echo "Total failed images: $FAILED_TOTAL"
              echo "Failed images can be retried in next run"
            fi
          fi

          echo "total-scanned=$SUCCESS_COUNT" >> $GITHUB_OUTPUT
          echo "successful-scans=$SUCCESS_COUNT" >> $GITHUB_OUTPUT
          echo "failed-scans=$FAILURE_COUNT" >> $GITHUB_OUTPUT

          if [ $SUCCESS_COUNT -gt 0 ]; then
            echo "✓ Batch scan completed with $SUCCESS_COUNT successful scans"
            if [ $SCAN_COUNT -lt $REMAINING_IMAGES ]; then
              echo "⚠ Note: Scan was interrupted. Run workflow again to resume from progress."
            fi
            exit 0
          else
            echo "✗ No successful scans in this run"
            if [ $SUCCESS_COUNT -gt 0 ]; then
              echo "  → But $SUCCESS_COUNT images were completed in previous runs"
              exit 0
            else
              exit 1
            fi
          fi

      - name: Upload scan progress immediately
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: scan-progress
          path: |
            scan_progress.txt
            completed_scans.txt
            failed_scans.txt
          retention-days: 30

      - name: Prepare results from recent scans or skip to organize
        if: steps.check-reuse.outputs.reuse-available == 'true' || github.event.inputs.skip_to_organize == 'true'
        id: prepare-recent
        run: |
          if [ "${{ github.event.inputs.skip_to_organize }}" == "true" ]; then
            echo "⏭ Skipping to organize existing results..."
            echo "Using existing trivy-results directory"
          else
            echo "Preparing recent scan results for processing..."
            # Copy recent results to current results directory
            mkdir -p trivy-results
            if [ -d "recent-results" ]; then
              cp -r recent-results/* trivy-results/ 2>/dev/null || true
            fi
          fi

          # Count available JSON files
          JSON_COUNT=0
          for json_file in trivy-results/*.json; do
            if [ -f "$json_file" ]; then
              JSON_COUNT=$((JSON_COUNT + 1))
            fi
          done

          echo "✓ Prepared $JSON_COUNT JSON files from recent scan"
          echo "⚡ Time saved by reusing recent results: ~120-180 minutes"
          echo "💰 Resources saved: Significant CPU, memory, and network usage"

          # Set outputs to match batch-scan outputs for consistency
          echo "successful-scans=$JSON_COUNT" >> $GITHUB_OUTPUT
          echo "total-scanned=$JSON_COUNT" >> $GITHUB_OUTPUT
          echo "failed-scans=0" >> $GITHUB_OUTPUT

      - name: Organize scan results by tool
        if: (steps.batch-scan.outputs.successful-scans > 0) || (steps.prepare-recent.outputs.successful-scans > 0)
        id: organize-results
        run: |
          echo "Organizing scan results by tool..."

          TOOL_MAPPING_FILE="tool_images_mapping.json"
          ORGANIZED_DIR="organized-results"
          mkdir -p "$ORGANIZED_DIR"

          if [ ! -f "$TOOL_MAPPING_FILE" ]; then
            echo "✗ Tool mapping file not found"
            exit 1
          fi

          # Validate tool mapping file
          if ! jq empty "$TOOL_MAPPING_FILE" 2>/dev/null; then
            echo "✗ Tool mapping file contains invalid JSON"
            exit 1
          fi

          # Get list of tools
          TOOLS=$(jq -r 'keys[]' "$TOOL_MAPPING_FILE" 2>/dev/null)
          if [ -z "$TOOLS" ]; then
            echo "✗ No tools found in mapping file"
            exit 1
          fi

          TOOL_COUNT=0
          echo "Processing tools and organizing scan results..."
          echo "Tools to process: $(echo "$TOOLS" | tr '\n' ' ')"

          for tool in $TOOLS; do
            TOOL_COUNT=$((TOOL_COUNT + 1))
            echo "[$TOOL_COUNT] Processing tool: $tool"
            
            # Create tool-specific result file
            TOOL_RESULT_FILE="$ORGANIZED_DIR/${tool}-trivy-scan-results.json"
            
            # Initialize tool result structure
            echo "{\"tool\": \"$tool\", \"scan_timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\", \"workflow_run_id\": \"${{ github.run_id }}\", \"versions\": {}, \"summary\": {\"total_versions_scanned\": 0, \"total_vulnerabilities\": 0}}" > "$TOOL_RESULT_FILE"

            # Process each image for this tool
            jq -r --arg tool "$tool" '.[$tool][]? | .image' "$TOOL_MAPPING_FILE" | while read -r image_url; do
              if [ -n "$image_url" ]; then
                # Find corresponding scan result file
                SAFE_NAME=$(echo "$image_url" | sed 's|[^a-zA-Z0-9._-]|_|g')
                SCAN_FILE="trivy-results/trivy-${SAFE_NAME}.json"
                
                if [ -f "$SCAN_FILE" ]; then
                  # Extract tag/version from image URL
                  TAG=$(echo "$image_url" | sed 's|.*:||')
                  echo "  → Adding results for version: $TAG"
                  
                  # Count vulnerabilities directly from file (avoid loading large data into memory)
                  VULN_COUNT=$(jq -r '[.Results[]?.Vulnerabilities[]?] | length' "$SCAN_FILE" 2>/dev/null || echo "0")
                  
                  # Create a temporary file with just the vulnerability data
                  TEMP_VULNS=$(mktemp)
                  jq -r '.Results[]?.Vulnerabilities // []' "$SCAN_FILE" > "$TEMP_VULNS" 2>/dev/null || echo "[]" > "$TEMP_VULNS"
                  
                  # Add version data to tool result file using file input instead of command line args
                  jq --arg tag "$TAG" \
                     --arg image "$image_url" \
                     --argjson count "$VULN_COUNT" \
                     --slurpfile vulns "$TEMP_VULNS" \
                     '.versions[$tag] = {
                       "image": $image,
                       "vulnerabilities": $vulns[0],
                       "vulnerability_count": $count
                     }' "$TOOL_RESULT_FILE" > "${TOOL_RESULT_FILE}.tmp" && mv "${TOOL_RESULT_FILE}.tmp" "$TOOL_RESULT_FILE"
                  
                  # Clean up temp file
                  rm -f "$TEMP_VULNS"
                  
                  echo "    ✓ Added $VULN_COUNT vulnerabilities"
                else
                  echo "  ⚠ Scan result not found for: $image_url"
                fi
              fi
            done

            # Update summary by counting from the actual data in the file
            VERSION_COUNT=$(jq -r '.versions | keys | length' "$TOOL_RESULT_FILE")
            TOTAL_VULNS=$(jq -r '[.versions[].vulnerability_count] | add // 0' "$TOOL_RESULT_FILE")
            
            jq --argjson version_count "$VERSION_COUNT" \
               --argjson total_vulns "$TOTAL_VULNS" \
               '.summary.total_versions_scanned = $version_count |
                .summary.total_vulnerabilities = $total_vulns' \
               "$TOOL_RESULT_FILE" > "${TOOL_RESULT_FILE}.tmp" && mv "${TOOL_RESULT_FILE}.tmp" "$TOOL_RESULT_FILE"

            echo "  ✓ Organized $VERSION_COUNT versions with $TOTAL_VULNS total vulnerabilities"
          done

          echo ""
          echo "✓ Organization complete. Processed $TOOL_COUNT tools"
          echo "organized-dir=$ORGANIZED_DIR" >> $GITHUB_OUTPUT
          echo "tool-count=$TOOL_COUNT" >> $GITHUB_OUTPUT

      - name: Create Pull Request with scan results
        if: steps.organize-results.outputs.tool-count > 0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating Pull Request with organized scan results..."

          ORGANIZED_DIR="${{ steps.organize-results.outputs.organized-dir }}"
          TOOL_COUNT="${{ steps.organize-results.outputs.tool-count }}"
          BRANCH_NAME="trivy-security-scan-$(date +%Y-%m-%d)"

          # Configure git
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # Check git status and clean working directory
          echo "Checking git status before creating branch..."
          git status --porcelain

          # Ensure clean working directory - stash any unintended changes
          if [ -n "$(git status --porcelain)" ]; then
            echo "Working directory not clean - stashing changes..."
            git stash push -m "Auto-stash before PR creation" --include-untracked
          fi

          # Create and switch to new branch from clean main
          git checkout -b "$BRANCH_NAME"

          # Debug: Check what files exist in organized directory
          echo "Checking organized directory: $ORGANIZED_DIR"
          if [ -d "$ORGANIZED_DIR" ]; then
            echo "Files in organized directory:"
            ls -la "$ORGANIZED_DIR"
          else
            echo "✗ Organized directory does not exist: $ORGANIZED_DIR"
            exit 1
          fi

          # Copy organized results to their respective tool directories
          COPIED_FILES=0
          echo "Looking for files matching pattern: $ORGANIZED_DIR/*-trivy-scan-results.json"

          # Use a more robust file finding approach
          if [ -d "$ORGANIZED_DIR" ]; then
            # First, let's use a simple approach that works with the COPIED_FILES counter
            for result_file in "$ORGANIZED_DIR"/*-trivy-scan-results.json; do
              # Check if the glob matched any files
              if [ ! -e "$result_file" ]; then
                echo "No files matching pattern found"
                break
              fi
              
              if [ -f "$result_file" ]; then
                echo "Processing file: $result_file"
                
                # Extract tool name from filename
                TOOL_NAME=$(basename "$result_file" | sed 's|-trivy-scan-results.json||')
                TARGET_DIR="bfx/$TOOL_NAME"
                TARGET_FILE="$TARGET_DIR/trivy-scan-results.json"
                
                echo "  → Tool: $TOOL_NAME"
                echo "  → Target directory: $TARGET_DIR"
                echo "  → Target file: $TARGET_FILE"
                
                if [ -d "$TARGET_DIR" ]; then
                  echo "  ✓ Target directory exists"
                  echo "Copying scan results for: $TOOL_NAME"
                  cp "$result_file" "$TARGET_FILE"
                  
                  # Only add the specific scan result file (not workflow files)
                  git add "$TARGET_FILE"
                  COPIED_FILES=$((COPIED_FILES + 1))
                  
                  # Show summary of what was added
                  VERSIONS=$(jq -r '.summary.total_versions_scanned' "$TARGET_FILE")
                  VULNS=$(jq -r '.summary.total_vulnerabilities' "$TARGET_FILE")
                  echo "  → $VERSIONS versions scanned, $VULNS vulnerabilities found"
                else
                  echo "  ✗ Target directory not found: $TARGET_DIR"
                  echo "  → Available directories in bfx/:"
                  ls -la bfx/ | head -10
                fi
              fi
            done
          else
            echo "✗ Organized directory not found: $ORGANIZED_DIR"
            exit 1
          fi

          # Verify what we're about to commit
          echo ""
          echo "Files staged for commit:"
          git diff --cached --name-only

          # Ensure no workflow files are staged
          if git diff --cached --name-only | grep -q "\.github/workflows/"; then
            echo "⚠ Workflow files detected in staging area - removing them"
            git reset HEAD .github/workflows/ 2>/dev/null || true
          fi

          if [ $COPIED_FILES -eq 0 ]; then
            echo "✗ No files were copied to target directories"
            exit 1
          fi

          # Final validation - ensure only scan result files are staged
          STAGED_FILES=$(git diff --cached --name-only)
          if [ -z "$STAGED_FILES" ]; then
            echo "✗ No files staged for commit"
            exit 1
          fi

          echo ""
          echo "Final validation - Files staged for commit:"
          echo "$STAGED_FILES"

          # Check if any non-scan-result files are staged
          NON_SCAN_FILES=$(echo "$STAGED_FILES" | grep -v "bfx/.*/trivy-scan-results\.json$" || true)
          if [ -n "$NON_SCAN_FILES" ]; then
            echo "⚠ WARNING: Non-scan-result files detected:"
            echo "$NON_SCAN_FILES"
            echo "Removing them from staging area..."
            echo "$NON_SCAN_FILES" | xargs git reset HEAD -- 2>/dev/null || true
          fi

          # Verify final staged files
          FINAL_STAGED=$(git diff --cached --name-only)
          echo "Final files to commit:"
          echo "$FINAL_STAGED"

          # Commit changes
          git commit -m "Update Trivy security scan results - $(date +%Y-%m-%d)

          - Updated security scan results for $COPIED_FILES tools
          - Scanned container images for CRITICAL and HIGH vulnerabilities
          - Results include vulnerability details and counts per version
          - Automated scan performed by Trivy Security Scan workflow"

          # Push branch with explicit handling
          echo "Pushing branch: $BRANCH_NAME"
          if ! git push origin "$BRANCH_NAME"; then
            echo "✗ Failed to push branch"
            echo "This might be due to workflow file permissions"
            echo "Checking what files are in the commit..."
            git show --name-only HEAD
            exit 1
          fi
          echo "✓ Branch pushed successfully"

          # Create PR description
          PR_BODY="## 🔒 Trivy Security Scan Results - $(date +%Y-%m-%d)

          This PR contains the latest security scan results from Trivy for our container images.

          ### 📊 Summary
          - **Tools scanned**: $COPIED_FILES
          - **Scan date**: $(date +%Y-%m-%d)
          - **Workflow run**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - **Severity levels**: CRITICAL, HIGH

          ### 📁 Files Updated
          $(for result_file in "$ORGANIZED_DIR"/*-trivy-scan-results.json; do
            if [ -f "$result_file" ]; then
              TOOL_NAME=$(basename "$result_file" | sed 's|-trivy-scan-results.json||')
              if [ -d "bfx/$TOOL_NAME" ]; then
                VERSIONS=$(jq -r '.summary.total_versions_scanned' "$result_file")
                VULNS=$(jq -r '.summary.total_vulnerabilities' "$result_file")
                echo "- \`bfx/$TOOL_NAME/trivy-scan-results.json\` - $VERSIONS versions, $VULNS vulnerabilities"
              fi
            fi
          done)

          ### 🔍 What's Included
          - JSON files containing vulnerability details for each tool
          - Results organized by tool and version
          - Only CRITICAL and HIGH severity vulnerabilities
          - Vulnerability counts and metadata

          ### 📋 Next Steps
          1. Review the scan results for each tool
          2. Address any CRITICAL vulnerabilities as priority
          3. Plan updates for affected container versions
          4. Merge this PR to update the security baseline

          ---
          *This PR was automatically generated by the Trivy Security Scan workflow.*"

          # Create pull request
          gh pr create \
            --title "Update Trivy security scan results - $(date +%Y-%m-%d)" \
            --body "$PR_BODY" \
            --base main \
            --head "$BRANCH_NAME" \
            --label "security,automated,trivy-scan"

          echo "✓ Pull Request created successfully"
          echo "  → Branch: $BRANCH_NAME"
          echo "  → Files updated: $COPIED_FILES"
          echo "  → PR URL: $(gh pr view --json url -q .url)"

      - name: Upload scan results as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: trivy-scan-results
          path: |
            trivy-results/
            organized-results/
          retention-days: 90

    outputs:
      total-scanned: ${{ steps.batch-scan.outputs.total-scanned || steps.prepare-recent.outputs.total-scanned }}
      successful-scans: ${{ steps.batch-scan.outputs.successful-scans || steps.prepare-recent.outputs.successful-scans }}
      failed-scans: ${{ steps.batch-scan.outputs.failed-scans || steps.prepare-recent.outputs.failed-scans }}
      used-recent-results: ${{ steps.check-reuse.outputs.reuse-available }}
      tool-count: ${{ steps.organize-results.outputs.tool-count }}

  summary:
    name: Scan Summary
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [check-recent-scans, security-scan, trivy-scan]
    if: always()

    steps:
      - name: Display comprehensive scan summary
        run: |
          echo "Trivy Security Scan Workflow Complete"
          echo "======================================"
          echo "Workflow execution time: $(date)"
          echo ""

          # Discovery phase summary
          echo "📋 Discovery Phase:"
          if [ "${{ needs.security-scan.outputs.image-count }}" -gt 0 ]; then
            echo "  ✓ Images discovered: ${{ needs.security-scan.outputs.image-count }}"
          else
            echo "  ⚠ No container images found to scan"
            echo "    → Verify images are published to ghcr.io with products/bfx/ prefix"
            echo "    → Check repository permissions for package access"
          fi
          echo ""

          # Scanning phase summary
          echo "🔍 Scanning Phase:"

          # Check if recent results were used
          if [ "${{ needs.trivy-scan.outputs.used-recent-results }}" == "true" ]; then
            echo "  🔄 Used recent scan results (within last month)"
            echo "    → Recent run ID: ${{ needs.check-recent-scans.outputs.recent-run-id }}"
            echo "    → Skipped re-scanning to save time and resources"
            echo "    → Results processed from previous successful scan"
          else
            echo "  💾 Checkpoint/Resume System Active"
            echo "    → Progress is saved after each successful scan"
            echo "    → Failed runs can be resumed from last checkpoint"
            echo "    → Use 'Resume from progress' option (enabled by default)"
          fi

          case "${{ needs.trivy-scan.result }}" in
            "success")
              if [ "${{ needs.trivy-scan.outputs.used-recent-results }}" == "true" ]; then
                echo "  ✓ Recent scan results processed successfully"
              else
                echo "  ✓ Batch scanning completed successfully"
              fi
              echo "  📊 Results:"
              echo "    → Tools processed: ${{ needs.trivy-scan.outputs.tool-count }}"
              echo "    → Images scanned: ${{ needs.trivy-scan.outputs.successful-scans }}"
              echo "    → Failed scans: ${{ needs.trivy-scan.outputs.failed-scans }}"
              echo "  📁 Output:"
              echo "    → JSON files created in bfx/<tool>/trivy-scan-results.json"
              echo "    → Pull Request created with all results"
              ;;
            "failure")
              echo "  ✗ Batch scanning encountered issues"
              echo "    → Check individual scan logs in workflow details"
              ;;
            "skipped")
              echo "  ⏭ Scanning was skipped (no images to process)"
              ;;
            *)
              echo "  ❓ Scanning status: ${{ needs.trivy-scan.result }}"
              ;;
          esac
          echo ""

          # Next steps
          echo "📋 Next Steps:"
          if [ "${{ needs.trivy-scan.result }}" == "success" ]; then
            echo "  1. Review the created Pull Request with scan results"
            echo "  2. Check individual tool directories: bfx/<tool>/trivy-scan-results.json"
            echo "  3. Address any CRITICAL vulnerabilities found"
            echo "  4. Plan container image updates for affected versions"
            echo "  5. Merge the PR to update the security baseline"
          elif [ "${{ needs.security-scan.outputs.image-count }}" -eq 0 ]; then
            echo "  1. Verify container images are published to ghcr.io"
            echo "  2. Check that images follow the products/bfx/* naming pattern"
            echo "  3. Ensure workflow has proper permissions to access packages"
          else
            echo "  1. Review workflow logs for specific error details"
            echo "  2. Check network connectivity and registry access"
            echo "  3. Verify Trivy configuration and image accessibility"
            echo "  4. If scan was interrupted, re-run workflow to resume from progress"
          fi

          echo ""
          echo "🔄 This workflow runs automatically on the first Sunday of every month"
          echo "   Manual execution: Use 'Run workflow' button in Actions tab"
