name: Trivy Security Scan

on:
  schedule:
    # Run on the first Sunday of every month at 2:00 AM UTC
    - cron: "0 2 1-7 * 0"
  workflow_dispatch:
    # Allow manual triggering of the workflow
    inputs:
      debug_mode:
        description: "Enable debug mode for troubleshooting"
        required: false
        default: false
        type: boolean
      force_fresh_scan:
        description: "Force fresh scan even if recent results are available"
        required: false
        default: false
        type: boolean

permissions:
  contents: write # Required for creating files and PRs
  packages: read # Required to access GitHub Container Registry
  pull-requests: write # Required to create pull requests
  actions: read # Required for workflow access

jobs:
  check-recent-scans:
    name: Check Recent Scan Results
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for recent successful scans
        id: check-recent
        run: |
          echo "Checking for recent successful scan results..."

          # Get recent workflow runs for this workflow
          WORKFLOW_NAME="Trivy Security Scan"
          ONE_MONTH_AGO=$(date -u -d '1 month ago' +%Y-%m-%dT%H:%M:%SZ)

          echo "Looking for successful runs since: $ONE_MONTH_AGO"

          # Check if user forced a fresh scan
          if [ "${{ github.event.inputs.force_fresh_scan }}" == "true" ]; then
            echo "🔄 Force fresh scan requested - will skip recent results check"
            echo "recent-scan-available=false" >> $GITHUB_OUTPUT
            echo "recent-run-id=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get recent workflow runs using GitHub API
          RECENT_RUNS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs?status=completed&conclusion=success&created=>$ONE_MONTH_AGO&per_page=10")

          # Check if we have any successful runs in the last month
          RECENT_SUCCESS_COUNT=$(echo "$RECENT_RUNS" | jq -r '.workflow_runs[] | select(.name == "'"$WORKFLOW_NAME"'" and .conclusion == "success") | .id' | wc -l)

          if [ "$RECENT_SUCCESS_COUNT" -gt 0 ]; then
            # Get the most recent successful run
            LATEST_RUN_ID=$(echo "$RECENT_RUNS" | jq -r '.workflow_runs[] | select(.name == "'"$WORKFLOW_NAME"'" and .conclusion == "success") | .id' | head -1)
            LATEST_RUN_DATE=$(echo "$RECENT_RUNS" | jq -r '.workflow_runs[] | select(.id == '"$LATEST_RUN_ID"') | .created_at')
            
            echo "✓ Found recent successful scan:"
            echo "  → Run ID: $LATEST_RUN_ID"
            echo "  → Date: $LATEST_RUN_DATE"
            echo "  → URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/$LATEST_RUN_ID"
            
            echo "recent-scan-available=true" >> $GITHUB_OUTPUT
            echo "recent-run-id=$LATEST_RUN_ID" >> $GITHUB_OUTPUT
          else
            echo "⚠ No recent successful scans found in the last month"
            echo "  → Will proceed with full scan"
            echo "recent-scan-available=false" >> $GITHUB_OUTPUT
            echo "recent-run-id=" >> $GITHUB_OUTPUT
          fi

    outputs:
      recent-scan-available: ${{ steps.check-recent.outputs.recent-scan-available }}
      recent-run-id: ${{ steps.check-recent.outputs.recent-run-id }}

  security-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: check-recent-scans

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Discover container images
        id: discover-images
        run: |
          echo "Discovering container images to scan..."

          # Create output file for discovered images
          IMAGES_FILE="images_to_scan.txt"
          > "$IMAGES_FILE"

          # Get organization name from repository
          ORG_NAME="${GITHUB_REPOSITORY_OWNER}"
          echo "Scanning packages for organization: $ORG_NAME"

          # Debug information
          echo ""
          echo "🔍 Environment Debug Information:"
          echo "================================="
          echo "  → Repository: ${GITHUB_REPOSITORY}"
          echo "  → Owner: ${GITHUB_REPOSITORY_OWNER}"
          echo "  → Actor: ${GITHUB_ACTOR}"
          echo "  → Token available: $([ -n "${{ secrets.GITHUB_TOKEN }}" ] && echo "Yes" || echo "No")"
          echo "  → Workflow permissions: packages:read, contents:write, pull-requests:write"
          echo ""

          # Determine which token to use
          if [ -n "${{ secrets.PACKAGES_TOKEN }}" ]; then
            echo "🔑 Using PACKAGES_TOKEN (Personal Access Token)"
            AUTH_TOKEN="${{ secrets.PACKAGES_TOKEN }}"
          else
            echo "🔑 Using GITHUB_TOKEN (default)"
            AUTH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          fi

          # Function to make API calls with retry logic
          make_api_call() {
            local url="$1"
            local max_retries=3
            local retry_delay=5
            local attempt=1
            
            while [ $attempt -le $max_retries ]; do
              echo "  → API call attempt $attempt/$max_retries: $url" >&2
              
              local response
              local http_code
              
              response=$(curl -s -w "%{http_code}" \
                             --max-time 30 \
                             --retry 0 \
                             -H "Authorization: Bearer $AUTH_TOKEN" \
                             -H "Accept: application/vnd.github.v3+json" \
                             "$url")
              http_code="${response: -3}"
              response="${response%???}"
              
              case "$http_code" in
                200)
                  echo "  ✓ API call successful (HTTP $http_code)" >&2
                  printf "%s" "$response"
                  return 0
                  ;;
                401|403|404)
                  echo "  ✗ API call failed (HTTP $http_code)" >&2
                  return 1
                  ;;
                429)
                  echo "  ⚠ Rate limit exceeded (HTTP $http_code)" >&2
                  if [ $attempt -lt $max_retries ]; then
                    local backoff_delay=$((retry_delay * attempt * 2))
                    echo "    → Rate limit backoff: waiting ${backoff_delay}s..." >&2
                    sleep $backoff_delay
                  fi
                  ;;
                5*)
                  echo "  ⚠ Server error (HTTP $http_code)" >&2
                  if [ $attempt -lt $max_retries ]; then
                    echo "    → Retrying in ${retry_delay}s..." >&2
                    sleep $retry_delay
                  fi
                  ;;
              esac
              
              attempt=$((attempt + 1))
            done
            
            echo "  ✗ API call failed after $max_retries attempts" >&2
            return 1
          }

          # Try organization endpoint first, then user endpoint if that fails
          echo "Fetching container packages from GitHub API..."

          ORG_URL="https://api.github.com/orgs/${ORG_NAME}/packages?package_type=container&per_page=100"
          set +e
          PACKAGES_RESPONSE=$(make_api_call "$ORG_URL")
          ORG_EXIT_CODE=$?
          set -e

          if [ $ORG_EXIT_CODE -eq 0 ] && [ -n "$PACKAGES_RESPONSE" ]; then
            echo "✓ Organization endpoint successful"
          else
            echo "✗ Organization endpoint failed, trying user endpoint..."
            USER_URL="https://api.github.com/users/${ORG_NAME}/packages?package_type=container&per_page=100"
            
            set +e
            PACKAGES_RESPONSE=$(make_api_call "$USER_URL")
            USER_EXIT_CODE=$?
            set -e
            
            if [ $USER_EXIT_CODE -eq 0 ] && [ -n "$PACKAGES_RESPONSE" ]; then
              echo "✓ User endpoint successful"
            else
              echo "✗ Both endpoints failed"
              exit 1
            fi
          fi

          # Validate and process packages
          if [ -z "$PACKAGES_RESPONSE" ]; then
            echo "✗ Empty response from GitHub API"
            exit 1
          fi

          TEMP_JSON=$(mktemp)
          printf "%s" "$PACKAGES_RESPONSE" > "$TEMP_JSON"

          if ! jq empty "$TEMP_JSON" 2>/dev/null; then
            echo "✗ Invalid JSON response from GitHub API"
            rm -f "$TEMP_JSON"
            exit 1
          fi

          # Extract and filter packages for products/bfx/* only
          ALL_PACKAGES_COUNT=$(jq '. | length' "$TEMP_JSON")
          echo "📦 Package Discovery Results:"
          echo "============================="
          echo "  → Total packages found: $ALL_PACKAGES_COUNT"

          # Get all package names and filter for products/bfx/*
          ALL_PACKAGE_NAMES=$(jq -r '.[].name' "$TEMP_JSON")
          BFX_PACKAGES=$(echo "$ALL_PACKAGE_NAMES" | grep "^products/bfx/" || true)
          BFX_COUNT=$(echo "$BFX_PACKAGES" | grep -c . 2>/dev/null || echo "0")

          echo "  → products/bfx/* packages found: $BFX_COUNT"

          if [ "$BFX_COUNT" -eq 0 ]; then
            echo "    ❌ No products/bfx/* packages found"
            rm -f "$TEMP_JSON"
            exit 1
          fi

          echo "$BFX_PACKAGES" | sed 's/^/    ✓ /'
          rm -f "$TEMP_JSON"

          # Process each package to get versions/tags and group by tool
          echo ""
          echo "🚀 Processing $BFX_COUNT products/bfx/* packages..."
          echo ""

          # Create a mapping file for tool -> images
          TOOL_IMAGES_FILE="tool_images_mapping.json"
          echo "{}" > "$TOOL_IMAGES_FILE"

          echo "$BFX_PACKAGES" | while read -r package_name; do
            if [ -n "$package_name" ]; then
              # Extract tool name from package (products/bfx/toolname -> toolname)
              TOOL_NAME=$(echo "$package_name" | sed 's|products/bfx/||')
              echo "Processing tool: $TOOL_NAME"
              
              # URL encode the package name
              encoded_package_name=$(echo "$package_name" | sed 's|/|%2F|g')
              
              # Get versions for this package
              VERSIONS_URL="https://api.github.com/orgs/${ORG_NAME}/packages/container/${encoded_package_name}/versions?per_page=100"
              VERSIONS_RESPONSE=$(make_api_call "$VERSIONS_URL")
              
              if [ $? -ne 0 ] || [ -z "$VERSIONS_RESPONSE" ]; then
                VERSIONS_URL="https://api.github.com/users/${ORG_NAME}/packages/container/${encoded_package_name}/versions?per_page=100"
                VERSIONS_RESPONSE=$(make_api_call "$VERSIONS_URL")
              fi
              
              if [ $? -eq 0 ] && [ -n "$VERSIONS_RESPONSE" ]; then
                # Validate versions response and extract tags
                if echo "$VERSIONS_RESPONSE" | jq empty 2>/dev/null && echo "$VERSIONS_RESPONSE" | jq -e 'type == "array"' >/dev/null 2>&1; then
                  VERSION_COUNT=$(echo "$VERSIONS_RESPONSE" | jq '. | length')
                  echo "  → Found $VERSION_COUNT versions for $TOOL_NAME"
                  
                  # Extract tags and create image URLs, add to tool mapping
                  echo "$VERSIONS_RESPONSE" | jq -r '.[].metadata.container.tags[]?' | while read -r tag; do
                    if [ -n "$tag" ] && [[ ! "$tag" == *.sig ]] && [[ ! "$tag" == sha256-* ]] && [[ "$tag" =~ ^[a-zA-Z0-9._:-]+$ ]]; then
                      image_url="ghcr.io/${ORG_NAME}/${package_name}:${tag}"
                      echo "$image_url" >> "$IMAGES_FILE"
                      
                      # Add to tool mapping
                      jq --arg tool "$TOOL_NAME" --arg image "$image_url" --arg tag "$tag" \
                        '.[$tool] = (.[$tool] // []) + [{"image": $image, "tag": $tag}]' \
                        "$TOOL_IMAGES_FILE" > "${TOOL_IMAGES_FILE}.tmp" && mv "${TOOL_IMAGES_FILE}.tmp" "$TOOL_IMAGES_FILE"
                      
                      echo "    ✓ Added: $image_url"
                    fi
                  done
                fi
              else
                echo "  ✗ Failed to fetch versions for $TOOL_NAME"
              fi
            fi
          done

          # Display summary
          if [ -f "$IMAGES_FILE" ] && [ -s "$IMAGES_FILE" ]; then
            IMAGE_COUNT=$(wc -l < "$IMAGES_FILE")
            echo ""
            echo "✓ Discovery complete. Found $IMAGE_COUNT images to scan"
            
            echo "images-file=$IMAGES_FILE" >> $GITHUB_OUTPUT
            echo "image-count=$IMAGE_COUNT" >> $GITHUB_OUTPUT
            echo "tool-mapping-file=$TOOL_IMAGES_FILE" >> $GITHUB_OUTPUT
          else
            echo ""
            echo "⚠ No images found to scan"
            echo "images-file=" >> $GITHUB_OUTPUT
            echo "image-count=0" >> $GITHUB_OUTPUT
            echo "tool-mapping-file=" >> $GITHUB_OUTPUT
          fi

      - name: Upload discovered images and mapping
        if: steps.discover-images.outputs.image-count > 0
        uses: actions/upload-artifact@v4
        with:
          name: discovered-images
          path: |
            ${{ steps.discover-images.outputs.images-file }}
            ${{ steps.discover-images.outputs.tool-mapping-file }}
          retention-days: 7

    outputs:
      image-count: ${{ steps.discover-images.outputs.image-count }}
      images-file: ${{ steps.discover-images.outputs.images-file }}
      tool-mapping-file: ${{ steps.discover-images.outputs.tool-mapping-file }}

  trivy-scan:
    name: Trivy Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 180
    needs: [check-recent-scans, security-scan]
    if: needs.security-scan.outputs.image-count > 0

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Trivy database cache
        uses: actions/cache@v4
        with:
          path: ~/.cache/trivy
          key: trivy-db-${{ runner.os }}-${{ github.run_id }}
          restore-keys: |
            trivy-db-${{ runner.os }}-
            trivy-db-

      - name: Download discovered images and mapping
        uses: actions/download-artifact@v4
        with:
          name: discovered-images

      - name: Check for recent scan results to reuse
        id: check-reuse
        if: needs.check-recent-scans.outputs.recent-scan-available == 'true' && github.event.inputs.force_fresh_scan != 'true'
        run: |
          echo "Attempting to download recent scan results..."

          RECENT_RUN_ID="${{ needs.check-recent-scans.outputs.recent-run-id }}"
          echo "Checking artifacts from run: $RECENT_RUN_ID"

          if command -v gh >/dev/null 2>&1; then
            echo "Using GitHub CLI to download artifacts..."
            if gh run download "$RECENT_RUN_ID" --name "trivy-scan-results" --dir recent-results 2>/dev/null; then
              echo "✓ Successfully downloaded recent scan results"
              echo "reuse-available=true" >> $GITHUB_OUTPUT
              
              if [ -d "recent-results" ] && find recent-results -name "*.json" -type f | head -1 >/dev/null; then
                JSON_COUNT=$(find recent-results -name "*.json" -type f | wc -l)
                echo "  → Found $JSON_COUNT JSON files in recent results"
                echo "json-count=$JSON_COUNT" >> $GITHUB_OUTPUT
              else
                echo "⚠ No JSON files found in recent results"
                echo "reuse-available=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "⚠ Failed to download recent scan results"
              echo "reuse-available=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "⚠ GitHub CLI not available, cannot download recent artifacts"
            echo "reuse-available=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Pre-warm Trivy database cache
        if: steps.check-reuse.outputs.reuse-available != 'true' || github.event.inputs.force_fresh_scan == 'true'
        run: |
          echo "Pre-warming Trivy database cache..."
          mkdir -p ~/.cache/trivy

          docker run --rm \
            -v "$HOME/.cache/trivy:/root/.cache/trivy" \
            -e TRIVY_CACHE_DIR="/root/.cache/trivy" \
            aquasec/trivy:latest image --download-db-only

          echo "✓ Trivy database cache pre-warmed"

      - name: Batch scan images with Trivy
        id: batch-scan
        timeout-minutes: 150
        if: steps.check-reuse.outputs.reuse-available != 'true' || github.event.inputs.force_fresh_scan == 'true'
        run: |
          IMAGES_FILE="images_to_scan.txt"
          SCAN_COUNT=0
          SUCCESS_COUNT=0
          FAILURE_COUNT=0
          TOTAL_IMAGES=$(wc -l < "$IMAGES_FILE")

          echo "Starting batch scan of $TOTAL_IMAGES images using Trivy..."

          # Log why we're doing a fresh scan
          if [ "${{ github.event.inputs.force_fresh_scan }}" == "true" ]; then
            echo "🔄 Performing fresh scan (forced by user input)"
          elif [ "${{ needs.check-recent-scans.outputs.recent-scan-available }}" == "true" ]; then
            echo "🔄 Performing fresh scan (recent results not usable)"
          else
            echo "🔄 Performing fresh scan (no recent results available)"
          fi
          echo ""

          # Set up results directory
          mkdir -p trivy-results

          # Process each image
          while IFS= read -r image_url; do
            if [ -n "$image_url" ]; then
              SCAN_COUNT=$((SCAN_COUNT + 1))
              echo "[$SCAN_COUNT/$TOTAL_IMAGES] Processing: $image_url"
              
              # Create safe filename for outputs
              SAFE_NAME=$(echo "$image_url" | sed 's|[^a-zA-Z0-9._-]|_|g')
              JSON_FILE="trivy-results/trivy-${SAFE_NAME}.json"
              
              # Attempt Trivy scan with JSON output
              if timeout 15m docker run --rm \
                --memory=2g \
                --cpus=2 \
                -v "$(pwd)/trivy-results:/output" \
                -v "$HOME/.cache/trivy:/root/.cache/trivy" \
                -e TRIVY_USERNAME="${{ github.actor }}" \
                -e TRIVY_PASSWORD="${{ secrets.GITHUB_TOKEN }}" \
                -e TRIVY_CACHE_DIR="/root/.cache/trivy" \
                aquasec/trivy:latest image \
                --format json \
                --severity CRITICAL,HIGH \
                --timeout 12m \
                --exit-code 0 \
                --skip-update \
                --output "/output/trivy-${SAFE_NAME}.json" \
                "$image_url" 2>/dev/null; then
                
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                echo "  ✓ Scan completed successfully"
                
                if [ -f "$JSON_FILE" ]; then
                  VULN_COUNT=$(jq -r '.Results[]?.Vulnerabilities // [] | length' "$JSON_FILE" 2>/dev/null | awk '{sum+=$1} END {print sum+0}')
                  echo "  → Found $VULN_COUNT vulnerabilities (CRITICAL/HIGH)"
                fi
              else
                FAILURE_COUNT=$((FAILURE_COUNT + 1))
                echo "  ✗ Scan failed - continuing with next image"
              fi
              
              echo ""
            fi
          done < "$IMAGES_FILE"

          echo "Batch Scan Summary"
          echo "=================="
          echo "Total images processed: $SCAN_COUNT"
          echo "Successful scans: $SUCCESS_COUNT"
          echo "Failed scans: $FAILURE_COUNT"

          echo "total-scanned=$SCAN_COUNT" >> $GITHUB_OUTPUT
          echo "successful-scans=$SUCCESS_COUNT" >> $GITHUB_OUTPUT
          echo "failed-scans=$FAILURE_COUNT" >> $GITHUB_OUTPUT

          if [ $SUCCESS_COUNT -gt 0 ]; then
            echo "✓ Batch scan completed with $SUCCESS_COUNT successful scans"
            exit 0
          else
            echo "✗ All scans failed"
            exit 1
          fi

      - name: Prepare results from recent scans
        if: steps.check-reuse.outputs.reuse-available == 'true'
        id: prepare-recent
        run: |
          echo "Preparing recent scan results for processing..."

          # Copy recent results to current results directory
          mkdir -p trivy-results
          if [ -d "recent-results" ]; then
            cp -r recent-results/* trivy-results/ 2>/dev/null || true
          fi

          # Count available JSON files
          JSON_COUNT=0
          for json_file in trivy-results/*.json; do
            if [ -f "$json_file" ]; then
              JSON_COUNT=$((JSON_COUNT + 1))
            fi
          done

          echo "✓ Prepared $JSON_COUNT JSON files from recent scan"
          echo "⚡ Time saved by reusing recent results: ~120-180 minutes"
          echo "💰 Resources saved: Significant CPU, memory, and network usage"

          # Set outputs to match batch-scan outputs for consistency
          echo "successful-scans=$JSON_COUNT" >> $GITHUB_OUTPUT
          echo "total-scanned=$JSON_COUNT" >> $GITHUB_OUTPUT
          echo "failed-scans=0" >> $GITHUB_OUTPUT

      - name: Organize scan results by tool
        if: (steps.batch-scan.outputs.successful-scans > 0) || (steps.prepare-recent.outputs.successful-scans > 0)
        id: organize-results
        run: |
          echo "Organizing scan results by tool..."

          TOOL_MAPPING_FILE="tool_images_mapping.json"
          ORGANIZED_DIR="organized-results"
          mkdir -p "$ORGANIZED_DIR"

          if [ ! -f "$TOOL_MAPPING_FILE" ]; then
            echo "✗ Tool mapping file not found"
            exit 1
          fi

          # Get list of tools
          TOOLS=$(jq -r 'keys[]' "$TOOL_MAPPING_FILE")
          TOOL_COUNT=0

          echo "Processing tools and organizing scan results..."

          for tool in $TOOLS; do
            TOOL_COUNT=$((TOOL_COUNT + 1))
            echo "[$TOOL_COUNT] Processing tool: $tool"
            
            # Create tool-specific result file
            TOOL_RESULT_FILE="$ORGANIZED_DIR/${tool}-trivy-scan-results.json"
            
            # Initialize tool result structure
            echo "{\"tool\": \"$tool\", \"scan_timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\", \"workflow_run_id\": \"${{ github.run_id }}\", \"versions\": {}, \"summary\": {\"total_versions_scanned\": 0, \"total_vulnerabilities\": 0}}" > "$TOOL_RESULT_FILE"

            # Get images for this tool
            TOOL_IMAGES=$(jq -r --arg tool "$tool" '.[$tool][]' "$TOOL_MAPPING_FILE")
            VERSION_COUNT=0
            TOTAL_VULNS=0

            echo "$TOOL_IMAGES" | jq -r '.image' | while read -r image_url; do
              if [ -n "$image_url" ]; then
                # Find corresponding scan result file
                SAFE_NAME=$(echo "$image_url" | sed 's|[^a-zA-Z0-9._-]|_|g')
                SCAN_FILE="trivy-results/trivy-${SAFE_NAME}.json"
                
                if [ -f "$SCAN_FILE" ]; then
                  # Extract tag/version from image URL
                  TAG=$(echo "$image_url" | sed 's|.*:||')
                  echo "  → Adding results for version: $TAG"
                  
                  # Extract vulnerabilities and count
                  VULNERABILITIES=$(jq -r '.Results[]?.Vulnerabilities // []' "$SCAN_FILE" 2>/dev/null || echo "[]")
                  VULN_COUNT=$(echo "$VULNERABILITIES" | jq 'length' 2>/dev/null || echo "0")
                  
                  # Add version data to tool result file
                  jq --arg tag "$TAG" \
                     --arg image "$image_url" \
                     --argjson vulns "$VULNERABILITIES" \
                     --argjson count "$VULN_COUNT" \
                     '.versions[$tag] = {
                       "image": $image,
                       "vulnerabilities": $vulns,
                       "vulnerability_count": $count
                     }' "$TOOL_RESULT_FILE" > "${TOOL_RESULT_FILE}.tmp" && mv "${TOOL_RESULT_FILE}.tmp" "$TOOL_RESULT_FILE"
                  
                  VERSION_COUNT=$((VERSION_COUNT + 1))
                  TOTAL_VULNS=$((TOTAL_VULNS + VULN_COUNT))
                else
                  echo "  ⚠ Scan result not found for: $image_url"
                fi
              fi
            done

            # Update summary
            jq --argjson version_count "$VERSION_COUNT" \
               --argjson total_vulns "$TOTAL_VULNS" \
               '.summary.total_versions_scanned = $version_count |
                .summary.total_vulnerabilities = $total_vulns' \
               "$TOOL_RESULT_FILE" > "${TOOL_RESULT_FILE}.tmp" && mv "${TOOL_RESULT_FILE}.tmp" "$TOOL_RESULT_FILE"

            echo "  ✓ Organized $VERSION_COUNT versions with $TOTAL_VULNS total vulnerabilities"
          done

          echo ""
          echo "✓ Organization complete. Processed $TOOL_COUNT tools"
          echo "organized-dir=$ORGANIZED_DIR" >> $GITHUB_OUTPUT
          echo "tool-count=$TOOL_COUNT" >> $GITHUB_OUTPUT

      - name: Create Pull Request with scan results
        if: steps.organize-results.outputs.tool-count > 0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating Pull Request with organized scan results..."

          ORGANIZED_DIR="${{ steps.organize-results.outputs.organized-dir }}"
          TOOL_COUNT="${{ steps.organize-results.outputs.tool-count }}"
          BRANCH_NAME="trivy-security-scan-$(date +%Y-%m-%d)"

          # Configure git
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # Create and switch to new branch
          git checkout -b "$BRANCH_NAME"

          # Copy organized results to their respective tool directories
          COPIED_FILES=0
          for result_file in "$ORGANIZED_DIR"/*-trivy-scan-results.json; do
            if [ -f "$result_file" ]; then
              # Extract tool name from filename
              TOOL_NAME=$(basename "$result_file" | sed 's|-trivy-scan-results.json||')
              TARGET_DIR="bfx/$TOOL_NAME"
              TARGET_FILE="$TARGET_DIR/trivy-scan-results.json"
              
              if [ -d "$TARGET_DIR" ]; then
                echo "Copying scan results for: $TOOL_NAME"
                cp "$result_file" "$TARGET_FILE"
                git add "$TARGET_FILE"
                COPIED_FILES=$((COPIED_FILES + 1))
                
                # Show summary of what was added
                VERSIONS=$(jq -r '.summary.total_versions_scanned' "$TARGET_FILE")
                VULNS=$(jq -r '.summary.total_vulnerabilities' "$TARGET_FILE")
                echo "  → $VERSIONS versions scanned, $VULNS vulnerabilities found"
              else
                echo "⚠ Target directory not found: $TARGET_DIR"
              fi
            fi
          done

          if [ $COPIED_FILES -eq 0 ]; then
            echo "✗ No files were copied to target directories"
            exit 1
          fi

          # Commit changes
          git commit -m "Update Trivy security scan results - $(date +%Y-%m-%d)

          - Updated security scan results for $COPIED_FILES tools
          - Scanned container images for CRITICAL and HIGH vulnerabilities
          - Results include vulnerability details and counts per version
          - Automated scan performed by Trivy Security Scan workflow"

          # Push branch
          git push origin "$BRANCH_NAME"

          # Create PR description
          PR_BODY="## 🔒 Trivy Security Scan Results - $(date +%Y-%m-%d)

          This PR contains the latest security scan results from Trivy for our container images.

          ### 📊 Summary
          - **Tools scanned**: $COPIED_FILES
          - **Scan date**: $(date +%Y-%m-%d)
          - **Workflow run**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - **Severity levels**: CRITICAL, HIGH

          ### 📁 Files Updated
          $(for result_file in "$ORGANIZED_DIR"/*-trivy-scan-results.json; do
            if [ -f "$result_file" ]; then
              TOOL_NAME=$(basename "$result_file" | sed 's|-trivy-scan-results.json||')
              if [ -d "bfx/$TOOL_NAME" ]; then
                VERSIONS=$(jq -r '.summary.total_versions_scanned' "$result_file")
                VULNS=$(jq -r '.summary.total_vulnerabilities' "$result_file")
                echo "- \`bfx/$TOOL_NAME/trivy-scan-results.json\` - $VERSIONS versions, $VULNS vulnerabilities"
              fi
            fi
          done)

          ### 🔍 What's Included
          - JSON files containing vulnerability details for each tool
          - Results organized by tool and version
          - Only CRITICAL and HIGH severity vulnerabilities
          - Vulnerability counts and metadata

          ### 📋 Next Steps
          1. Review the scan results for each tool
          2. Address any CRITICAL vulnerabilities as priority
          3. Plan updates for affected container versions
          4. Merge this PR to update the security baseline

          ---
          *This PR was automatically generated by the Trivy Security Scan workflow.*"

          # Create pull request
          gh pr create \
            --title "Update Trivy security scan results - $(date +%Y-%m-%d)" \
            --body "$PR_BODY" \
            --base main \
            --head "$BRANCH_NAME" \
            --label "security,automated,trivy-scan"

          echo "✓ Pull Request created successfully"
          echo "  → Branch: $BRANCH_NAME"
          echo "  → Files updated: $COPIED_FILES"
          echo "  → PR URL: $(gh pr view --json url -q .url)"

      - name: Upload scan results as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: trivy-scan-results
          path: |
            trivy-results/
            organized-results/
          retention-days: 90

    outputs:
      total-scanned: ${{ steps.batch-scan.outputs.total-scanned || steps.prepare-recent.outputs.total-scanned }}
      successful-scans: ${{ steps.batch-scan.outputs.successful-scans || steps.prepare-recent.outputs.successful-scans }}
      failed-scans: ${{ steps.batch-scan.outputs.failed-scans || steps.prepare-recent.outputs.failed-scans }}
      used-recent-results: ${{ steps.check-reuse.outputs.reuse-available }}
      tool-count: ${{ steps.organize-results.outputs.tool-count }}

  summary:
    name: Scan Summary
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [check-recent-scans, security-scan, trivy-scan]
    if: always()

    steps:
      - name: Display comprehensive scan summary
        run: |
          echo "Trivy Security Scan Workflow Complete"
          echo "======================================"
          echo "Workflow execution time: $(date)"
          echo ""

          # Discovery phase summary
          echo "📋 Discovery Phase:"
          if [ "${{ needs.security-scan.outputs.image-count }}" -gt 0 ]; then
            echo "  ✓ Images discovered: ${{ needs.security-scan.outputs.image-count }}"
          else
            echo "  ⚠ No container images found to scan"
            echo "    → Verify images are published to ghcr.io with products/bfx/ prefix"
            echo "    → Check repository permissions for package access"
          fi
          echo ""

          # Scanning phase summary
          echo "🔍 Scanning Phase:"

          # Check if recent results were used
          if [ "${{ needs.trivy-scan.outputs.used-recent-results }}" == "true" ]; then
            echo "  🔄 Used recent scan results (within last month)"
            echo "    → Recent run ID: ${{ needs.check-recent-scans.outputs.recent-run-id }}"
            echo "    → Skipped re-scanning to save time and resources"
            echo "    → Results processed from previous successful scan"
          fi

          case "${{ needs.trivy-scan.result }}" in
            "success")
              if [ "${{ needs.trivy-scan.outputs.used-recent-results }}" == "true" ]; then
                echo "  ✓ Recent scan results processed successfully"
              else
                echo "  ✓ Batch scanning completed successfully"
              fi
              echo "  📊 Results:"
              echo "    → Tools processed: ${{ needs.trivy-scan.outputs.tool-count }}"
              echo "    → Images scanned: ${{ needs.trivy-scan.outputs.successful-scans }}"
              echo "    → Failed scans: ${{ needs.trivy-scan.outputs.failed-scans }}"
              echo "  📁 Output:"
              echo "    → JSON files created in bfx/<tool>/trivy-scan-results.json"
              echo "    → Pull Request created with all results"
              ;;
            "failure")
              echo "  ✗ Batch scanning encountered issues"
              echo "    → Check individual scan logs in workflow details"
              ;;
            "skipped")
              echo "  ⏭ Scanning was skipped (no images to process)"
              ;;
            *)
              echo "  ❓ Scanning status: ${{ needs.trivy-scan.result }}"
              ;;
          esac
          echo ""

          # Next steps
          echo "📋 Next Steps:"
          if [ "${{ needs.trivy-scan.result }}" == "success" ]; then
            echo "  1. Review the created Pull Request with scan results"
            echo "  2. Check individual tool directories: bfx/<tool>/trivy-scan-results.json"
            echo "  3. Address any CRITICAL vulnerabilities found"
            echo "  4. Plan container image updates for affected versions"
            echo "  5. Merge the PR to update the security baseline"
          elif [ "${{ needs.security-scan.outputs.image-count }}" -eq 0 ]; then
            echo "  1. Verify container images are published to ghcr.io"
            echo "  2. Check that images follow the products/bfx/* naming pattern"
            echo "  3. Ensure workflow has proper permissions to access packages"
          else
            echo "  1. Review workflow logs for specific error details"
            echo "  2. Check network connectivity and registry access"
            echo "  3. Verify Trivy configuration and image accessibility"
          fi

          echo ""
          echo "🔄 This workflow runs automatically on the first Sunday of every month"
          echo "   Manual execution: Use 'Run workflow' button in Actions tab"
