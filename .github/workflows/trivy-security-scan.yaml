name: Trivy Security Scan

on:
  schedule:
    # Run every Sunday at 2:00 AM UTC
    - cron: "0 2 * * 0"
  workflow_dispatch:
    # Allow manual triggering of the workflow
    inputs:
      debug_mode:
        description: "Enable debug mode for troubleshooting"
        required: false
        default: false
        type: boolean
      force_fresh_scan:
        description: "Force fresh scan even if recent results are available"
        required: false
        default: false
        type: boolean

permissions:
  contents: read # Required for checkout action
  packages: read # Required to access GitHub Container Registry
  security-events: write # Required to upload SARIF results to Security tab
  actions: read # Required for workflow access
  pull-requests: read # Sometimes needed for full access

jobs:
  check-recent-scans:
    name: Check Recent Scan Results
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for recent successful scans
        id: check-recent
        run: |
          echo "Checking for recent successful scan results..."

          # Get recent workflow runs for this workflow
          WORKFLOW_NAME="Trivy Security Scan"
          ONE_HOUR_AGO=$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ)

          echo "Looking for successful runs since: $ONE_HOUR_AGO"

          # Check if user forced a fresh scan
          if [ "${{ github.event.inputs.force_fresh_scan }}" == "true" ]; then
            echo "🔄 Force fresh scan requested - will skip recent results check"
            echo "recent-scan-available=false" >> $GITHUB_OUTPUT
            echo "recent-run-id=" >> $GITHUB_OUTPUT
            return 0
          fi

          # Get recent workflow runs using GitHub API
          RECENT_RUNS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs?status=completed&conclusion=success&created=>$ONE_HOUR_AGO&per_page=10")

          # Check if we have any successful runs in the last hour
          RECENT_SUCCESS_COUNT=$(echo "$RECENT_RUNS" | jq -r '.workflow_runs[] | select(.name == "'"$WORKFLOW_NAME"'" and .conclusion == "success") | .id' | wc -l)

          if [ "$RECENT_SUCCESS_COUNT" -gt 0 ]; then
            # Get the most recent successful run
            LATEST_RUN_ID=$(echo "$RECENT_RUNS" | jq -r '.workflow_runs[] | select(.name == "'"$WORKFLOW_NAME"'" and .conclusion == "success") | .id' | head -1)
            LATEST_RUN_DATE=$(echo "$RECENT_RUNS" | jq -r '.workflow_runs[] | select(.id == '"$LATEST_RUN_ID"') | .created_at')
            
            echo "✓ Found recent successful scan:"
            echo "  → Run ID: $LATEST_RUN_ID"
            echo "  → Date: $LATEST_RUN_DATE"
            echo "  → URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/$LATEST_RUN_ID"
            
            echo "recent-scan-available=true" >> $GITHUB_OUTPUT
            echo "recent-run-id=$LATEST_RUN_ID" >> $GITHUB_OUTPUT
          else
            echo "⚠ No recent successful scans found in the last hour"
            echo "  → Will proceed with full scan"
            echo "recent-scan-available=false" >> $GITHUB_OUTPUT
            echo "recent-run-id=" >> $GITHUB_OUTPUT
          fi

    outputs:
      recent-scan-available: ${{ steps.check-recent.outputs.recent-scan-available }}
      recent-run-id: ${{ steps.check-recent.outputs.recent-run-id }}

  security-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Discover container images
        id: discover-images
        run: |
          echo "Discovering container images to scan..."

          # Create output file for discovered images
          IMAGES_FILE="images_to_scan.txt"
          > "$IMAGES_FILE"

          # Get organization name from repository
          ORG_NAME="${GITHUB_REPOSITORY_OWNER}"
          echo "Scanning packages for organization: $ORG_NAME"

          # Debug information
          echo ""
          echo "🔍 Environment Debug Information:"
          echo "================================="
          echo "  → Repository: ${GITHUB_REPOSITORY}"
          echo "  → Owner: ${GITHUB_REPOSITORY_OWNER}"
          echo "  → Actor: ${GITHUB_ACTOR}"
          echo "  → Token available: $([ -n "${{ secrets.GITHUB_TOKEN }}" ] && echo "Yes" || echo "No")"
          echo "  → Workflow permissions: packages:read, security-events:write, contents:read"
          echo ""

          # Determine which token to use
          if [ -n "${{ secrets.PACKAGES_TOKEN }}" ]; then
            echo "🔑 Using PACKAGES_TOKEN (Personal Access Token)"
            AUTH_TOKEN="${{ secrets.PACKAGES_TOKEN }}"
          else
            echo "🔑 Using GITHUB_TOKEN (default)"
            AUTH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          fi

          # Test basic API access first
          echo "🔧 Testing GitHub API Access:"
          echo "=============================="
          echo "→ Testing basic API connectivity..."

          # Test with a simple API call that should always work
          if curl -s -f -H "Authorization: Bearer $AUTH_TOKEN" \
                    -H "Accept: application/vnd.github.v3+json" \
                    "https://api.github.com/user" > /dev/null; then
            echo "✓ Basic API access successful"
          else
            echo "✗ Basic API access failed"
            echo "  → Token may be invalid or have insufficient permissions"
            echo ""
            echo "💡 Solutions to try:"
            echo "  1. Check repository Settings → Actions → General → Workflow permissions"
            echo "  2. Ensure 'Read and write permissions' is selected"
            echo "  3. Or create a Personal Access Token with 'packages:read' scope"
            echo "  4. Add it as PACKAGES_TOKEN secret in repository settings"
            echo ""
            echo "🔍 Current token info:"
            echo "  → Using: $([ -n "${{ secrets.PACKAGES_TOKEN }}" ] && echo "PACKAGES_TOKEN (PAT)" || echo "GITHUB_TOKEN (default)")"
            echo "  → Repository: ${GITHUB_REPOSITORY}"
            echo "  → Actor: ${GITHUB_ACTOR}"
            exit 1
          fi

          # Function to make API calls with retry logic and rate limit optimization
          make_api_call() {
            local url="$1"
            local max_retries=3
            local retry_delay=5
            local attempt=1
            
            while [ $attempt -le $max_retries ]; do
              echo "  → API call attempt $attempt/$max_retries: $url" >&2
              
              # Make the API call with timeout and proper error handling
              local response
              local http_code
              
              response=$(curl -s -w "%{http_code}" \
                             --max-time 30 \
                             --retry 0 \
                             -H "Authorization: Bearer $AUTH_TOKEN" \
                             -H "Accept: application/vnd.github.v3+json" \
                             "$url")
              http_code="${response: -3}"
              response="${response%???}"
              
              case "$http_code" in
                200)
                  echo "  ✓ API call successful (HTTP $http_code)" >&2
                  printf "%s" "$response"
                  return 0
                  ;;
                401)
                  echo "  ✗ Authentication failed (HTTP $http_code)" >&2
                  return 1
                  ;;
                403)
                  echo "  ✗ Access forbidden (HTTP $http_code)" >&2
                  return 1
                  ;;
                404)
                  echo "  ✗ Resource not found (HTTP $http_code)" >&2
                  return 1
                  ;;
                429)
                  echo "  ⚠ Rate limit exceeded (HTTP $http_code)" >&2
                  if [ $attempt -lt $max_retries ]; then
                    local backoff_delay=$((retry_delay * attempt * 2 + RANDOM % 10))
                    echo "    → Rate limit backoff: waiting ${backoff_delay}s before retry..." >&2
                    sleep $backoff_delay
                  fi
                  ;;
                5*)
                  echo "  ⚠ Server error (HTTP $http_code)" >&2
                  if [ $attempt -lt $max_retries ]; then
                    echo "    → Retrying in ${retry_delay}s..." >&2
                    sleep $retry_delay
                  fi
                  ;;
                *)
                  echo "  ✗ Unexpected response (HTTP $http_code)" >&2
                  if [ $attempt -lt $max_retries ]; then
                    echo "    → Retrying in ${retry_delay}s..." >&2
                    sleep $retry_delay
                  fi
                  ;;
              esac
              
              attempt=$((attempt + 1))
            done
            
            echo "  ✗ API call failed after $max_retries attempts" >&2
            return 1
          }

          # Try organization endpoint first, then user endpoint if that fails
          echo "Fetching container packages from GitHub API..."

          # Try organization endpoint first
          echo "→ Attempting organization endpoint..."
          ORG_URL="https://api.github.com/orgs/${ORG_NAME}/packages?package_type=container&per_page=100"

          set +e
          PACKAGES_RESPONSE=$(make_api_call "$ORG_URL")
          ORG_EXIT_CODE=$?
          set -e

          if [ $ORG_EXIT_CODE -eq 0 ] && [ -n "$PACKAGES_RESPONSE" ]; then
            echo "✓ Organization endpoint successful"
          else
            echo "✗ Organization endpoint failed, trying user endpoint..."
            USER_URL="https://api.github.com/users/${ORG_NAME}/packages?package_type=container&per_page=100"
            
            set +e
            PACKAGES_RESPONSE=$(make_api_call "$USER_URL")
            USER_EXIT_CODE=$?
            set -e
            
            if [ $USER_EXIT_CODE -eq 0 ] && [ -n "$PACKAGES_RESPONSE" ]; then
              echo "✓ User endpoint successful"
            else
              echo "✗ Both endpoints failed"
              exit 1
            fi
          fi

          # Validate API response
          if [ -z "$PACKAGES_RESPONSE" ]; then
            echo "✗ Empty response from GitHub API"
            exit 1
          fi

          # Validate JSON response format
          TEMP_JSON=$(mktemp)
          printf "%s" "$PACKAGES_RESPONSE" > "$TEMP_JSON"

          if ! jq empty "$TEMP_JSON" 2>/dev/null; then
            echo "✗ Invalid JSON response from GitHub API"
            rm -f "$TEMP_JSON"
            exit 1
          fi

          # Extract and filter packages for products/bfx/* only
          ALL_PACKAGES_COUNT=$(jq '. | length' "$TEMP_JSON")
          echo "📦 Package Discovery Results:"
          echo "============================="
          echo "  → Total packages found: $ALL_PACKAGES_COUNT"

          # Get all package names and filter for products/bfx/*
          ALL_PACKAGE_NAMES=$(jq -r '.[].name' "$TEMP_JSON")
          BFX_PACKAGES=$(echo "$ALL_PACKAGE_NAMES" | grep "^products/bfx/" || true)
          BFX_COUNT=$(echo "$BFX_PACKAGES" | grep -c . 2>/dev/null || echo "0")

          echo "  → products/bfx/* packages found: $BFX_COUNT"

          if [ "$BFX_COUNT" -eq 0 ]; then
            echo "    ❌ No products/bfx/* packages found"
            echo ""
            echo "🔍 All package names for debugging:"
            echo "$ALL_PACKAGE_NAMES" | head -10 | sed 's/^/    - /'
            rm -f "$TEMP_JSON"
            exit 1
          fi

          echo "$BFX_PACKAGES" | sed 's/^/    ✓ /'
          rm -f "$TEMP_JSON"

          # Process each package to get versions/tags
          TOTAL_PACKAGES=$BFX_COUNT
          PACKAGE_COUNT=0

          echo ""
          echo "🚀 Processing $TOTAL_PACKAGES products/bfx/* packages..."
          echo ""

          echo "$BFX_PACKAGES" | while read -r package_name; do
            if [ -n "$package_name" ]; then
              PACKAGE_COUNT=$((PACKAGE_COUNT + 1))
              echo "[$PACKAGE_COUNT/$TOTAL_PACKAGES] Processing: $package_name"
              
              # Rate limiting
              if [ $PACKAGE_COUNT -gt 1 ]; then
                sleep 1
              fi
              
              # URL encode the package name
              encoded_package_name=$(echo "$package_name" | sed 's|/|%2F|g')
              
              # Get versions for this package
              VERSIONS_URL="https://api.github.com/orgs/${ORG_NAME}/packages/container/${encoded_package_name}/versions?per_page=100"
              VERSIONS_RESPONSE=$(make_api_call "$VERSIONS_URL")
              
              if [ $? -ne 0 ] || [ -z "$VERSIONS_RESPONSE" ]; then
                VERSIONS_URL="https://api.github.com/users/${ORG_NAME}/packages/container/${encoded_package_name}/versions?per_page=100"
                VERSIONS_RESPONSE=$(make_api_call "$VERSIONS_URL")
              fi
              
              if [ $? -eq 0 ] && [ -n "$VERSIONS_RESPONSE" ]; then
                # Validate versions response
                if echo "$VERSIONS_RESPONSE" | jq empty 2>/dev/null && echo "$VERSIONS_RESPONSE" | jq -e 'type == "array"' >/dev/null 2>&1; then
                  VERSION_COUNT=$(echo "$VERSIONS_RESPONSE" | jq '. | length')
                  echo "  → Found $VERSION_COUNT versions for package"
                  
                  # Extract tags and create image URLs
                  echo "$VERSIONS_RESPONSE" | jq -r '.[].metadata.container.tags[]?' | while read -r tag; do
                    if [ -n "$tag" ] && [[ ! "$tag" == *.sig ]] && [[ ! "$tag" == sha256-* ]] && [[ "$tag" =~ ^[a-zA-Z0-9._:-]+$ ]]; then
                      image_url="ghcr.io/${ORG_NAME}/${package_name}:${tag}"
                      echo "$image_url" >> "$IMAGES_FILE"
                      echo "    ✓ Found image: $image_url"
                    fi
                  done
                fi
              else
                echo "  ✗ Failed to fetch versions for package $package_name"
              fi
            fi
          done

          # Display summary
          if [ -f "$IMAGES_FILE" ] && [ -s "$IMAGES_FILE" ]; then
            IMAGE_COUNT=$(wc -l < "$IMAGES_FILE")
            echo ""
            echo "✓ Discovery complete. Found $IMAGE_COUNT images to scan:"
            cat "$IMAGES_FILE"
            
            echo "images-file=$IMAGES_FILE" >> $GITHUB_OUTPUT
            echo "image-count=$IMAGE_COUNT" >> $GITHUB_OUTPUT
          else
            echo ""
            echo "⚠ No images found to scan"
            echo "images-file=" >> $GITHUB_OUTPUT
            echo "image-count=0" >> $GITHUB_OUTPUT
          fi

      - name: Upload discovered images list
        if: steps.discover-images.outputs.image-count > 0
        uses: actions/upload-artifact@v4
        with:
          name: discovered-images
          path: ${{ steps.discover-images.outputs.images-file }}
          retention-days: 7

    outputs:
      image-count: ${{ steps.discover-images.outputs.image-count }}
      images-file: ${{ steps.discover-images.outputs.images-file }}

  trivy-scan:
    name: Trivy Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 120
    needs: [check-recent-scans, security-scan]
    if: needs.security-scan.outputs.image-count > 0

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Trivy database cache
        uses: actions/cache@v4
        with:
          path: ~/.cache/trivy
          key: trivy-db-${{ runner.os }}-${{ github.run_id }}
          restore-keys: |
            trivy-db-${{ runner.os }}-
            trivy-db-

      - name: Download discovered images list
        uses: actions/download-artifact@v4
        with:
          name: discovered-images

      - name: Check for recent scan results to reuse
        id: check-reuse
        if: needs.check-recent-scans.outputs.recent-scan-available == 'true' && github.event.inputs.force_fresh_scan != 'true'
        run: |
          echo "Attempting to download recent scan results..."

          RECENT_RUN_ID="${{ needs.check-recent-scans.outputs.recent-run-id }}"
          echo "Checking artifacts from run: $RECENT_RUN_ID"

          # Try to download recent scan results using GitHub CLI if available, otherwise use API
          if command -v gh >/dev/null 2>&1; then
            echo "Using GitHub CLI to download artifacts..."
            if gh run download "$RECENT_RUN_ID" --name "trivy-scan-results" --dir recent-results 2>/dev/null; then
              echo "✓ Successfully downloaded recent scan results"
              echo "reuse-available=true" >> $GITHUB_OUTPUT
              
              # Check if the results contain SARIF files
              if [ -d "recent-results" ] && find recent-results -name "*.sarif" -type f | head -1 >/dev/null; then
                SARIF_COUNT=$(find recent-results -name "*.sarif" -type f | wc -l)
                echo "  → Found $SARIF_COUNT SARIF files in recent results"
                echo "sarif-count=$SARIF_COUNT" >> $GITHUB_OUTPUT
              else
                echo "⚠ No SARIF files found in recent results"
                echo "reuse-available=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "⚠ Failed to download recent scan results"
              echo "reuse-available=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "⚠ GitHub CLI not available, cannot download recent artifacts"
            echo "reuse-available=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Pre-warm Trivy database cache
        run: |
          echo "Pre-warming Trivy database cache..."
          mkdir -p ~/.cache/trivy

          docker run --rm \
            -v "$HOME/.cache/trivy:/root/.cache/trivy" \
            -e TRIVY_CACHE_DIR="/root/.cache/trivy" \
            aquasec/trivy:latest image --download-db-only

          echo "✓ Trivy database cache pre-warmed"

      - name: Batch scan images with Trivy
        id: batch-scan
        timeout-minutes: 90
        if: steps.check-reuse.outputs.reuse-available != 'true' || github.event.inputs.force_fresh_scan == 'true'
        run: |
          IMAGES_FILE="images_to_scan.txt"
          SCAN_COUNT=0
          SUCCESS_COUNT=0
          FAILURE_COUNT=0
          TOTAL_IMAGES=$(wc -l < "$IMAGES_FILE")

          echo "Starting batch scan of $TOTAL_IMAGES images using Trivy..."

          # Log why we're doing a fresh scan
          if [ "${{ github.event.inputs.force_fresh_scan }}" == "true" ]; then
            echo "🔄 Performing fresh scan (forced by user input)"
          elif [ "${{ needs.check-recent-scans.outputs.recent-scan-available }}" == "true" ]; then
            echo "🔄 Performing fresh scan (recent results not usable)"
          else
            echo "🔄 Performing fresh scan (no recent results available)"
          fi
          echo ""

          # Set up results directory
          mkdir -p trivy-results

          # Process each image
          while IFS= read -r image_url; do
            if [ -n "$image_url" ]; then
              SCAN_COUNT=$((SCAN_COUNT + 1))
              echo "[$SCAN_COUNT/$TOTAL_IMAGES] Processing: $image_url"
              
              # Create safe filename for outputs
              SAFE_NAME=$(echo "$image_url" | sed 's|[^a-zA-Z0-9._-]|_|g')
              SARIF_FILE="trivy-results/trivy-${SAFE_NAME}.sarif"
              
              # Attempt Trivy scan
              if timeout 15m docker run --rm \
                --memory=2g \
                --cpus=2 \
                -v "$(pwd)/trivy-results:/output" \
                -v "$HOME/.cache/trivy:/root/.cache/trivy" \
                -e TRIVY_USERNAME="${{ github.actor }}" \
                -e TRIVY_PASSWORD="${{ secrets.GITHUB_TOKEN }}" \
                -e TRIVY_CACHE_DIR="/root/.cache/trivy" \
                aquasec/trivy:latest image \
                --format sarif \
                --severity CRITICAL,HIGH \
                --timeout 12m \
                --exit-code 0 \
                --skip-update \
                --output "/output/trivy-${SAFE_NAME}.sarif" \
                "$image_url" 2>/dev/null; then
                
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                echo "  ✓ Scan completed successfully"
                
                if [ -f "$SARIF_FILE" ]; then
                  VULN_COUNT=$(jq -r '.runs[0].results | length' "$SARIF_FILE" 2>/dev/null || echo "0")
                  echo "  → Found $VULN_COUNT vulnerabilities (CRITICAL/HIGH)"
                fi
              else
                FAILURE_COUNT=$((FAILURE_COUNT + 1))
                echo "  ✗ Scan failed - continuing with next image"
              fi
              
              echo ""
            fi
          done < "$IMAGES_FILE"

          echo "Batch Scan Summary"
          echo "=================="
          echo "Total images processed: $SCAN_COUNT"
          echo "Successful scans: $SUCCESS_COUNT"
          echo "Failed scans: $FAILURE_COUNT"

          echo "total-scanned=$SCAN_COUNT" >> $GITHUB_OUTPUT
          echo "successful-scans=$SUCCESS_COUNT" >> $GITHUB_OUTPUT
          echo "failed-scans=$FAILURE_COUNT" >> $GITHUB_OUTPUT

          if [ $SUCCESS_COUNT -gt 0 ]; then
            echo "✓ Batch scan completed with $SUCCESS_COUNT successful scans"
            exit 0
          else
            echo "✗ All scans failed"
            exit 1
          fi

      - name: Prepare results from recent scans
        if: steps.check-reuse.outputs.reuse-available == 'true'
        id: prepare-recent
        run: |
          echo "Preparing recent scan results for upload..."

          # Copy recent results to current results directory
          mkdir -p trivy-results
          if [ -d "recent-results" ]; then
            cp -r recent-results/* trivy-results/ 2>/dev/null || true
          fi

          # Count available SARIF files
          SARIF_COUNT=0
          for sarif_file in trivy-results/*.sarif; do
            if [ -f "$sarif_file" ]; then
              SARIF_COUNT=$((SARIF_COUNT + 1))
            fi
          done

          echo "✓ Prepared $SARIF_COUNT SARIF files from recent scan"
          echo "⚡ Time saved by reusing recent results: ~60-90 minutes"
          echo "💰 Resources saved: Significant CPU, memory, and network usage"
          echo "sarif-count=$SARIF_COUNT" >> $GITHUB_OUTPUT

          # Set outputs to match batch-scan outputs for consistency
          echo "successful-scans=$SARIF_COUNT" >> $GITHUB_OUTPUT
          echo "total-scanned=$SARIF_COUNT" >> $GITHUB_OUTPUT
          echo "failed-scans=0" >> $GITHUB_OUTPUT

      - name: Combine SARIF files for upload
        if: (steps.batch-scan.outputs.successful-scans > 0) || (steps.prepare-recent.outputs.sarif-count > 0)
        id: prepare-sarif
        run: |
          echo "Combining SARIF files for GitHub Security upload..."

          SARIF_COUNT=0
          # Count SARIF files
          for sarif_file in trivy-results/*.sarif; do
            if [ -f "$sarif_file" ]; then
              SARIF_COUNT=$((SARIF_COUNT + 1))
            fi
          done

          if [ "$SARIF_COUNT" -eq 0 ]; then
            echo "No SARIF files found to upload"
            echo "sarif-count=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Found $SARIF_COUNT SARIF files to combine"

          # Create combined SARIF file
          COMBINED_SARIF="trivy-results/trivy-combined-scan.sarif"

          # Try simple approach first - just use the first valid SARIF file if only one exists
          if [ "$SARIF_COUNT" -eq 1 ]; then
            FIRST_SARIF=$(find trivy-results -name "*.sarif" -type f | head -1)
            if [ -f "$FIRST_SARIF" ] && jq -e '.runs[0].tool' "$FIRST_SARIF" >/dev/null 2>&1; then
              echo "Only one SARIF file found, using it directly"
              cp "$FIRST_SARIF" "$COMBINED_SARIF"
              echo "sarif-count=1" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # Initialize the combined SARIF structure for multiple files
          echo '{
            "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
            "version": "2.1.0",
            "runs": []
          }' > "$COMBINED_SARIF"

          # Combine all runs from individual SARIF files
          echo "Combining SARIF runs into single file..."
          for sarif_file in trivy-results/*.sarif; do
            if [ -f "$sarif_file" ] && [ "$sarif_file" != "$COMBINED_SARIF" ]; then
              echo "  → Processing: $(basename "$sarif_file")"
              
              # Validate the SARIF file first
              if ! jq empty "$sarif_file" 2>/dev/null; then
                echo "    ⚠ Skipping invalid JSON file: $(basename "$sarif_file")"
                continue
              fi
              
              # Check if the SARIF file has runs
              RUN_COUNT=$(jq -r '.runs | length' "$sarif_file" 2>/dev/null || echo "0")
              if [ "$RUN_COUNT" -eq 0 ]; then
                echo "    ⚠ Skipping file with no runs: $(basename "$sarif_file")"
                continue
              fi
              
              echo "    → Adding $RUN_COUNT run(s) from: $(basename "$sarif_file")"
              
              # Extract all runs from this SARIF file and add them to the combined file
              jq --slurpfile combined "$COMBINED_SARIF" \
                 --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                 --arg workflow_run "${{ github.run_id }}" \
                 --arg repository "${{ github.repository }}" \
                 --arg source_file "$(basename "$sarif_file")" \
                 '
                 # Add metadata to each run and combine
                 .runs[] |= (
                   .properties = {
                     "workflow_run": $workflow_run,
                     "repository": $repository,
                     "scan_timestamp": $timestamp,
                     "source_file": $source_file
                   }
                 ) |
                 # Combine with existing runs
                 $combined[0] | .runs += .runs
                 ' "$sarif_file" > "${COMBINED_SARIF}.tmp"
              
              if [ $? -eq 0 ] && [ -f "${COMBINED_SARIF}.tmp" ]; then
                mv "${COMBINED_SARIF}.tmp" "$COMBINED_SARIF"
                echo "    ✓ Successfully added runs"
              else
                echo "    ✗ Failed to process file"
                rm -f "${COMBINED_SARIF}.tmp"
              fi
            fi
          done

          # Keep individual SARIF files as backup in case combined upload fails
          echo "Keeping individual SARIF files as backup for fallback upload"

          # Validate the combined SARIF file
          if [ -f "$COMBINED_SARIF" ] && jq empty "$COMBINED_SARIF" 2>/dev/null; then
            TOTAL_RUNS=$(jq -r '.runs | length' "$COMBINED_SARIF" 2>/dev/null || echo "0")
            
            if [ "$TOTAL_RUNS" -gt 0 ]; then
              # Calculate total vulnerabilities safely
              TOTAL_VULNS=$(jq -r '[.runs[]? | .results[]? | length] | add // 0' "$COMBINED_SARIF" 2>/dev/null || echo "0")
              
              echo "✓ Combined SARIF file created successfully"
              echo "  → Total runs: $TOTAL_RUNS"
              echo "  → Total vulnerabilities: $TOTAL_VULNS"
              echo "  → File: $(basename "$COMBINED_SARIF")"
              echo "  → File size: $(du -h "$COMBINED_SARIF" | cut -f1)"
              
              # Validate SARIF structure
              if jq -e '.runs[0].tool' "$COMBINED_SARIF" >/dev/null 2>&1; then
                echo "  ✓ SARIF structure validation passed"
                echo "sarif-count=1" >> $GITHUB_OUTPUT
              else
                echo "  ✗ SARIF structure validation failed - missing tool information"
                echo "  → This may cause upload issues"
                echo "sarif-count=0" >> $GITHUB_OUTPUT
              fi
            else
              echo "✗ Combined SARIF file has no runs"
              echo "sarif-count=0" >> $GITHUB_OUTPUT
            fi
          else
            echo "✗ Failed to create valid combined SARIF file"
            if [ -f "$COMBINED_SARIF" ]; then
              echo "  → File exists but contains invalid JSON"
              echo "  → File size: $(du -h "$COMBINED_SARIF" | cut -f1)"
              # Show first few lines for debugging
              echo "  → First 5 lines:"
              head -5 "$COMBINED_SARIF" | sed 's/^/    /'
            else
              echo "  → File was not created"
            fi
            echo "sarif-count=0" >> $GITHUB_OUTPUT
          fi

      - name: Upload combined SARIF to GitHub Security
        if: steps.prepare-sarif.outputs.sarif-count > 0
        id: upload-sarif
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-results/trivy-combined-scan.sarif
          category: trivy-container-security-scan
          checkout_path: ${{ github.workspace }}
          wait-for-processing: true
        continue-on-error: true

      - name: Fallback - Upload individual SARIF files
        if: steps.prepare-sarif.outputs.sarif-count == 0 && ((steps.batch-scan.outputs.successful-scans > 0) || (steps.prepare-recent.outputs.sarif-count > 0))
        run: |
          echo "Combined SARIF upload failed, attempting individual file uploads..."

          # Restore individual SARIF files if they were removed
          if [ -d "recent-results" ] && [ "${{ steps.check-reuse.outputs.reuse-available }}" == "true" ]; then
            echo "Restoring individual SARIF files from recent results..."
            cp recent-results/*.sarif trivy-results/ 2>/dev/null || true
          fi

          UPLOAD_COUNT=0
          for sarif_file in trivy-results/*.sarif; do
            if [ -f "$sarif_file" ] && [[ "$(basename "$sarif_file")" != "trivy-combined-scan.sarif" ]]; then
              echo "Attempting to upload: $(basename "$sarif_file")"
              
              # Create unique category for each file to avoid conflicts
              SAFE_NAME=$(basename "$sarif_file" .sarif)
              CATEGORY="trivy-scan-${SAFE_NAME}"
              
              # Validate individual SARIF file
              if jq empty "$sarif_file" 2>/dev/null && jq -e '.runs[0].tool' "$sarif_file" >/dev/null 2>&1; then
                echo "  → Uploading with category: $CATEGORY"
                
                # Use GitHub CLI to upload if available
                if command -v gh >/dev/null 2>&1; then
                  if gh api repos/${{ github.repository }}/code-scanning/sarifs \
                    --method POST \
                    --field "commit_sha=${{ github.sha }}" \
                    --field "ref=${{ github.ref }}" \
                    --field "sarif=@$sarif_file" \
                    --field "category=$CATEGORY" 2>/dev/null; then
                    echo "  ✓ Successfully uploaded via API"
                    UPLOAD_COUNT=$((UPLOAD_COUNT + 1))
                  else
                    echo "  ✗ API upload failed"
                  fi
                else
                  echo "  ⚠ GitHub CLI not available for fallback upload"
                fi
              else
                echo "  ✗ Invalid SARIF file, skipping"
              fi
            fi
          done

          if [ $UPLOAD_COUNT -gt 0 ]; then
            echo "✓ Successfully uploaded $UPLOAD_COUNT individual SARIF files"
          else
            echo "✗ Failed to upload any SARIF files"
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload scan results as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: trivy-scan-results
          path: trivy-results/
          retention-days: 30

    outputs:
      total-scanned: ${{ steps.batch-scan.outputs.total-scanned || steps.prepare-recent.outputs.total-scanned }}
      successful-scans: ${{ steps.batch-scan.outputs.successful-scans || steps.prepare-recent.outputs.successful-scans }}
      failed-scans: ${{ steps.batch-scan.outputs.failed-scans || steps.prepare-recent.outputs.failed-scans }}
      used-recent-results: ${{ steps.check-reuse.outputs.reuse-available }}

  summary:
    name: Scan Summary
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [check-recent-scans, security-scan, trivy-scan]
    if: always()

    steps:
      - name: Download scan results for summary
        if: needs.trivy-scan.result != 'skipped'
        uses: actions/download-artifact@v4
        with:
          name: trivy-scan-results
          path: scan-results/
        continue-on-error: true

      - name: Display comprehensive scan summary
        run: |
          echo "Trivy Security Scan Workflow Complete"
          echo "======================================"
          echo "Workflow execution time: $(date)"
          echo ""

          # Discovery phase summary
          echo "📋 Discovery Phase:"
          if [ "${{ needs.security-scan.outputs.image-count }}" -gt 0 ]; then
            echo "  ✓ Images discovered: ${{ needs.security-scan.outputs.image-count }}"
          else
            echo "  ⚠ No container images found to scan"
            echo "    → Verify images are published to ghcr.io with products/bfx/ prefix"
            echo "    → Check repository permissions for package access"
          fi
          echo ""

          # Scanning phase summary
          echo "🔍 Scanning Phase:"

          # Check if recent results were used
          if [ "${{ needs.trivy-scan.outputs.used-recent-results }}" == "true" ]; then
            echo "  🔄 Used recent scan results (within last hour)"
            echo "    → Recent run ID: ${{ needs.check-recent-scans.outputs.recent-run-id }}"
            echo "    → Skipped re-scanning to save time and resources"
            echo "    → Results uploaded from previous successful scan"
          fi

          case "${{ needs.trivy-scan.result }}" in
            "success")
              if [ "${{ needs.trivy-scan.outputs.used-recent-results }}" == "true" ]; then
                echo "  ✓ Recent scan results processed and uploaded successfully"
              else
                echo "  ✓ Batch scanning completed successfully"
              fi
              echo "  📁 Results Location:"
              echo "    → GitHub Security tab: ${{ github.server_url }}/${{ github.repository }}/security"
              echo "    → Code Scanning Alerts: ${{ github.server_url }}/${{ github.repository }}/security/code-scanning"
              echo "    → Filter by category: 'trivy-container-security-scan'"
              ;;
            "failure")
              echo "  ✗ Batch scanning encountered issues"
              echo "    → Check individual scan logs in workflow details"
              ;;
            "skipped")
              echo "  ⏭ Scanning was skipped (no images to process)"
              ;;
            *)
              echo "  ❓ Scanning status: ${{ needs.trivy-scan.result }}"
              ;;
          esac
          echo ""

          # Next steps
          echo "� Nnext Steps:"
          if [ "${{ needs.trivy-scan.result }}" == "success" ]; then
            echo "  1. Navigate to GitHub Security tab to review uploaded SARIF results"
            echo "  2. Filter code scanning alerts by 'trivy-container-security-scan' category"
            echo "  3. Review CRITICAL and HIGH severity vulnerabilities by image"
            echo "  4. Track remediation progress using GitHub Security features"
          elif [ "${{ needs.security-scan.outputs.image-count }}" -eq 0 ]; then
            echo "  1. Verify container images are published to ghcr.io"
            echo "  2. Check that images follow the products/bfx/* naming pattern"
            echo "  3. Ensure workflow has proper permissions to access packages"
          else
            echo "  1. Review workflow logs for specific error details"
            echo "  2. Check network connectivity and registry access"
            echo "  3. Verify Trivy configuration and image accessibility"
          fi

          echo ""
          echo "🔄 This workflow runs automatically every Sunday at 2:00 AM UTC"
          echo "   Manual execution: Use 'Run workflow' button in Actions tab"
