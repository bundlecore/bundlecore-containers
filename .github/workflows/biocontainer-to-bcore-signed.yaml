name: Retag and Sign BioContainer Images
# This workflow is triggered by a push to the biocontainers directory or manually 
on:
  workflow_dispatch:
  push:
    paths:
      - 'bfx/**'

jobs:
  retag-sign:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Set up Cosign
        uses: sigstore/cosign-installer@v4.0.0

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Retag and sign images
        env:
          GHCR_ORG: ${{ github.repository_owner }}
          BCORE_AUTH_TOKEN: ${{ secrets.BCORE_AUTH_TOKEN_PROD }}
          PROD_DOMAIN: bfx
        run: |
          set -e

          # Function to update BundleCore with new tool version
          update_bundlecore_tool_version() {
              local app_name=$1
              local new_version=$2
              local original_image=$3
              local bc_registry_url=$4

              echo "Updating BundleCore API for $app_name version $new_version..."

              # Check if this version already exists in BundleCore
              local versions_data=$(curl -sS -H "Authorization: Bearer ${BCORE_AUTH_TOKEN}" "https://bundlecore.com/api/tools/${app_name}/versions")

              if [ -z "$versions_data" ]; then
                  echo "⚠️  Warning: Failed to fetch versions for $app_name from BundleCore API" >&2
                  return 0
              fi

              # Check if new version already exists
              local existing_versions=$(echo "$versions_data" | jq -r '.data.versions[].version')
              for ver in $existing_versions; do
                  if [[ "$ver" == "$new_version" ]]; then
                      echo "ℹ️  Version $new_version already exists for $app_name in BundleCore"
                      return 0
                  fi
              done

              echo "Adding new version $new_version for $app_name to BundleCore..."

              # Extract the first version object as template
              local template_body=$(echo "$versions_data" | jq '.data.versions[0]')

              if [ -z "$template_body" ] || [ "$template_body" == "null" ]; then
                  echo "⚠️  Warning: No existing versions found for $app_name to use as template" >&2
                  return 0
              fi

              echo "Using template from version: $(echo "$template_body" | jq -r '.version')"

              # Update the version, bcRegistryUrl, and registryUrl fields in the template
              local updated_body=$(echo "$template_body" | jq \
                  --arg new_ver "$new_version" \
                  --arg bc_registry "$bc_registry_url" \
                  --arg registry "$original_image" \
                  '.version = $new_ver |
                  .bcRegistryUrl = $bc_registry |
                  .registryUrl = $registry')

              echo "Updated body: $updated_body"

              # POST the updated version to BundleCore
              response=$(curl -sS -w "%{http_code}" -o /tmp/curl_response -X POST \
                  -H "Authorization: Bearer ${BCORE_AUTH_TOKEN}" \
                  -H "Content-Type: application/json" \
                  -d "$updated_body" \
                  "https://bundlecore.com/api/tools/${app_name}/versions")

              if [ "$response" -ne 200 ]; then
                  echo "⚠️  Warning: Failed to update BundleCore for $app_name. HTTP status: $response" >&2
                  echo "Response body: $(cat /tmp/curl_response)" >&2
                  return 0
              fi

              echo "✅ Successfully added version $new_version for $app_name to BundleCore"
              echo "   bcRegistryUrl: $bc_registry_url"
              echo "   registryUrl: $original_image"
              return 0
          }

            for appdir in bfx/*/; do
            app=$(basename "$appdir")
            slug=$(basename "$appdir" | tr '[:upper:]' '[:lower:]')
            release_json="${appdir}release.json"

            if [ ! -f "$release_json" ]; then
              echo "No release.json for $app, skipping"
              continue
            fi
            
            images=$(jq -r '.images[]' "$release_json")
            for img in $images; do
                tag="${img##*:}"
                # remove everything after '--' (e.g. '1.21--h3a4d415_1' -> '1.21')
                tag="${tag%%--*}"
                dest="ghcr.io/${GHCR_ORG}/products/${PROD_DOMAIN}/${slug}:${tag}"
                if docker manifest inspect "$dest" > /dev/null 2>&1; then
                  echo "Image $dest already exists, skipping"
                  continue
                fi
                echo "Processing $img -> $dest"
                docker pull "$img"
                docker tag "$img" "$dest"
                docker push "$dest"
                cosign sign --yes "$dest"

                # Update BundleCore API with new version
                update_bundlecore_tool_version "$slug" "$tag" "$img" "$dest" || true

            done
            # Check if there are any docker images before cleanup
            if docker images -q | grep -q .; then
              echo "Cleaning up docker images and cache..."
              # clean up local images
              docker images -q | xargs -r -n1 docker rmi -f || true
              # remove build cache, dangling images and unused data
              docker builder prune -af || true
              docker image prune -af || true
              docker system prune -af --volumes || true
            fi
          done
