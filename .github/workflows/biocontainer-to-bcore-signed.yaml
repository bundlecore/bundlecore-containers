name: Retag and Sign BioContainer Images
# This workflow is triggered by a push to the biocontainers directory or manually 
on:
  workflow_dispatch:
  push:
    paths:
      - 'bfx/**'

jobs:
  retag-sign:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Set up Cosign
        uses: sigstore/cosign-installer@v4.0.0

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Retag and sign images
        env:
          GHCR_ORG: ${{ github.repository_owner }}
          BCORE_AUTH_TOKEN: ${{ secrets.BCORE_AUTH_TOKEN_PROD }}
          PROD_DOMAIN: bfx
        run: |
          set -e

          # Function to update BundleCore with new tool version
          update_bundlecore_tool_version() {
              local app_name=$1
              local new_version=$2
              local original_image=$3
              local bc_registry_url=$4

              echo "Updating BundleCore API for $app_name version $new_version..."

              # Fetch existing versions from BundleCore
              local versions_data=$(curl -sS -H "Authorization: Bearer ${BCORE_AUTH_TOKEN}" "https://bundlecore.com/api/tools/${app_name}/versions")

              if [ -z "$versions_data" ]; then
                  echo "âš ï¸  Warning: Failed to fetch versions for $app_name from BundleCore API" >&2
                  return 0
              fi

              # Check if this version already exists and get its bcRegistryUrl
              local existing_version=$(echo "$versions_data" | jq -r --arg ver "$new_version" '.data.versions[] | select(.version == $ver)')
              
              if [ -n "$existing_version" ] && [ "$existing_version" != "null" ]; then
                  local existing_bc_registry=$(echo "$existing_version" | jq -r '.bcRegistryUrl')
                  
                  if [ -n "$existing_bc_registry" ] && [ "$existing_bc_registry" != "" ] && [ "$existing_bc_registry" != "null" ]; then
                      echo "â„¹ï¸  Version $new_version already exists for $app_name with bcRegistryUrl: $existing_bc_registry"
                      return 0
                  fi
                  
                  echo "ðŸ“ Version $new_version exists but bcRegistryUrl is empty, updating..."
                  
                  # Update the existing version with bcRegistryUrl
                  local updated_body=$(echo "$existing_version" | jq \
                      --arg bc_registry "$bc_registry_url" \
                      --arg registry "$original_image" \
                      '.bcRegistryUrl = $bc_registry |
                      .registryUrl = $registry')

                  echo "Updated body: $updated_body"

                  # PUT to update the existing version
                  response=$(curl -sS -w "%{http_code}" -o /tmp/curl_response -X PUT \
                      -H "Authorization: Bearer ${BCORE_AUTH_TOKEN}" \
                      -H "Content-Type: application/json" \
                      -d "$updated_body" \
                      "https://bundlecore.com/api/tools/${app_name}/versions/${new_version}")

                  if [ "$response" -ne 200 ]; then
                      echo "âš ï¸  Warning: Failed to update BundleCore for $app_name. HTTP status: $response" >&2
                      echo "Response body: $(cat /tmp/curl_response)" >&2
                      return 0
                  fi

                  echo "âœ… Successfully updated version $new_version for $app_name in BundleCore"
                  echo "   bcRegistryUrl: $bc_registry_url"
                  echo "   registryUrl: $original_image"
                  return 0
              fi

              # Version doesn't exist, create a new one
              echo "âž• Creating new version $new_version for $app_name in BundleCore..."

              # Extract the first version object as template
              local template_body=$(echo "$versions_data" | jq '.data.versions[0]')

              if [ -z "$template_body" ] || [ "$template_body" == "null" ]; then
                  echo "âš ï¸  Warning: No existing versions found for $app_name to use as template" >&2
                  return 0
              fi

              echo "Using template from version: $(echo "$template_body" | jq -r '.version')"

              # Create new version body from template
              local new_body=$(echo "$template_body" | jq \
                  --arg new_ver "$new_version" \
                  --arg bc_registry "$bc_registry_url" \
                  --arg registry "$original_image" \
                  '.version = $new_ver |
                  .bcRegistryUrl = $bc_registry |
                  .registryUrl = $registry')

              echo "New version body: $new_body"

              # POST to create new version
              response=$(curl -sS -w "%{http_code}" -o /tmp/curl_response -X POST \
                  -H "Authorization: Bearer ${BCORE_AUTH_TOKEN}" \
                  -H "Content-Type: application/json" \
                  -d "$new_body" \
                  "https://bundlecore.com/api/tools/${app_name}/versions")

              if [ "$response" -ne 200 ]; then
                  echo "âš ï¸  Warning: Failed to create version in BundleCore for $app_name. HTTP status: $response" >&2
                  echo "Response body: $(cat /tmp/curl_response)" >&2
                  return 0
              fi

              echo "âœ… Successfully created version $new_version for $app_name in BundleCore"
              echo "   bcRegistryUrl: $bc_registry_url"
              echo "   registryUrl: $original_image"
              return 0
          }

            for appdir in bfx/*/; do
            app=$(basename "$appdir")
            slug=$(basename "$appdir" | tr '[:upper:]' '[:lower:]')
            release_json="${appdir}release.json"

            if [ ! -f "$release_json" ]; then
              echo "No release.json for $app, skipping"
              continue
            fi
            
            images=$(jq -r '.images[]' "$release_json")
            for img in $images; do
                tag="${img##*:}"
                # remove everything after '--' (e.g. '1.21--h3a4d415_1' -> '1.21')
                tag="${tag%%--*}"
                dest="ghcr.io/${GHCR_ORG}/products/${PROD_DOMAIN}/${slug}:${tag}"
                if docker manifest inspect "$dest" > /dev/null 2>&1; then
                  echo "Image $dest already exists, skipping"
                  continue
                fi
                echo "Processing $img -> $dest"
                docker pull "$img"
                docker tag "$img" "$dest"
                docker push "$dest"
                cosign sign --yes "$dest"

                # Update BundleCore API with new version
                update_bundlecore_tool_version "$slug" "$tag" "$img" "$dest" || true

            done
            # Check if there are any docker images before cleanup
            if docker images -q | grep -q .; then
              echo "Cleaning up docker images and cache..."
              # clean up local images
              docker images -q | xargs -r -n1 docker rmi -f || true
              # remove build cache, dangling images and unused data
              docker builder prune -af || true
              docker image prune -af || true
              docker system prune -af --volumes || true
            fi
          done
