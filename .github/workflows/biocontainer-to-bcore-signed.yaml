name: Retag and Sign BioContainer Images
# Triggered on release.json changes (new tool version) or manually.
# On push: only processes the tools whose release.json changed.
# On workflow_dispatch: processes all tools by default, or changed-only if selected.
on:
  workflow_dispatch:
    inputs:
      scan_mode:
        description: "Retag scope: all tools or only recently changed"
        required: false
        default: "all"
        type: choice
        options:
          - all
          - changed-only
  push:
    branches:
      - main
    paths:
      - "bfx/*/release.json" # Only trigger when a tool version is added/updated

jobs:
  retag-sign:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2 # Needed to diff against the previous commit

      - name: Set up jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Set up Cosign
        uses: sigstore/cosign-installer@v4.0.0

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Retag and sign images
        env:
          GHCR_ORG: ${{ github.repository_owner }}
          BCORE_AUTH_TOKEN: ${{ secrets.BCORE_AUTH_TOKEN_PROD }}
          PROD_DOMAIN: bfx
        run: |
          set -e

          EVENT="${{ github.event_name }}"
          SCAN_MODE="${{ github.event.inputs.scan_mode }}"

          # â”€â”€ Determine which tool directories to process â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          if [ "$EVENT" = "push" ] || { [ "$EVENT" = "workflow_dispatch" ] && [ "$SCAN_MODE" = "changed-only" ]; }; then
            echo "ðŸ” Incremental mode â€” diffing bfx/ against previous commit..."
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD -- bfx/ 2>/dev/null || true)

            if [ -z "$CHANGED_FILES" ]; then
              echo "  â†’ No changes detected in bfx/ â€” nothing to retag"
              exit 0
            fi

            echo "Changed files:"
            echo "$CHANGED_FILES" | sed 's/^/  - /'

            # Extract unique tool dirs from changed paths: bfx/<tool>/release.json â†’ bfx/<tool>/
            TOOL_DIRS=$(echo "$CHANGED_FILES" \
              | grep '^bfx/' \
              | sed 's|^bfx/||' \
              | cut -d'/' -f1 \
              | sort -u \
              | sed 's|^|bfx/|; s|$|/|')

            if [ -z "$TOOL_DIRS" ]; then
              echo "  â†’ No tool-level changes found â€” nothing to retag"
              exit 0
            fi

            echo ""
            echo "ðŸ›  Tools to retag:"
            echo "$TOOL_DIRS" | sed 's/^/  âœ“ /'
          else
            echo "ðŸ“‹ Full mode â€” retagging ALL tools in bfx/"
            TOOL_DIRS=$(find bfx -mindepth 1 -maxdepth 1 -type d | sort | sed 's|$|/|')
          fi

          # â”€â”€ Helper: update BundleCore API with new tool version â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          update_bundlecore_tool_version() {
              local app_name=$1
              local new_version=$2
              local original_image=$3
              local bc_registry_url=$4

              echo "Updating BundleCore API for $app_name version $new_version..."

              local versions_data=$(curl -sS -H "Authorization: Bearer ${BCORE_AUTH_TOKEN}" "https://bundlecore.com/api/tools/${app_name}/versions")

              if [ -z "$versions_data" ]; then
                  echo "âš ï¸  Warning: Failed to fetch versions for $app_name from BundleCore API" >&2
                  return 0
              fi

              local existing_version=$(echo "$versions_data" | jq -r --arg ver "$new_version" '.data.versions[] | select(.version == $ver)')

              if [ -n "$existing_version" ] && [ "$existing_version" != "null" ]; then
                  local existing_bc_registry=$(echo "$existing_version" | jq -r '.bcRegistryUrl')

                  if [ -n "$existing_bc_registry" ] && [ "$existing_bc_registry" != "" ] && [ "$existing_bc_registry" != "null" ]; then
                      echo "â„¹ï¸  Version $new_version already exists for $app_name with bcRegistryUrl: $existing_bc_registry"
                      return 0
                  fi

                  echo "ðŸ“ Version $new_version exists but bcRegistryUrl is empty, updating..."

                  local updated_body=$(echo "$existing_version" | jq \
                      --arg bc_registry "$bc_registry_url" \
                      --arg registry "$original_image" \
                      '.bcRegistryUrl = $bc_registry |
                      .registryUrl = $registry')

                  echo "Updated body: $updated_body"

                  response=$(curl -sS -w "%{http_code}" -o /tmp/curl_response -X PUT \
                      -H "Authorization: Bearer ${BCORE_AUTH_TOKEN}" \
                      -H "Content-Type: application/json" \
                      -d "$updated_body" \
                      "https://bundlecore.com/api/tools/${app_name}/versions/${new_version}")

                  if [ "$response" -ne 200 ]; then
                      echo "âš ï¸  Warning: Failed to update BundleCore for $app_name. HTTP status: $response" >&2
                      echo "Response body: $(cat /tmp/curl_response)" >&2
                      return 0
                  fi

                  echo "âœ… Successfully updated version $new_version for $app_name in BundleCore"
                  echo "   bcRegistryUrl: $bc_registry_url"
                  echo "   registryUrl: $original_image"
                  return 0
              fi

              # Version doesn't exist â€” create a new one
              echo "âž• Creating new version $new_version for $app_name in BundleCore..."

              local template_body=$(echo "$versions_data" | jq '.data.versions[0]')

              if [ -z "$template_body" ] || [ "$template_body" == "null" ]; then
                  echo "âš ï¸  Warning: No existing versions found for $app_name to use as template" >&2
                  return 0
              fi

              echo "Using template from version: $(echo "$template_body" | jq -r '.version')"

              local new_body=$(echo "$template_body" | jq \
                  --arg new_ver "$new_version" \
                  --arg bc_registry "$bc_registry_url" \
                  --arg registry "$original_image" \
                  '.version = $new_ver |
                  .bcRegistryUrl = $bc_registry |
                  .registryUrl = $registry')

              echo "New version body: $new_body"

              response=$(curl -sS -w "%{http_code}" -o /tmp/curl_response -X POST \
                  -H "Authorization: Bearer ${BCORE_AUTH_TOKEN}" \
                  -H "Content-Type: application/json" \
                  -d "$new_body" \
                  "https://bundlecore.com/api/tools/${app_name}/versions")

              if [ "$response" -ne 200 ]; then
                  echo "âš ï¸  Warning: Failed to create version in BundleCore for $app_name. HTTP status: $response" >&2
                  echo "Response body: $(cat /tmp/curl_response)" >&2
                  return 0
              fi

              echo "âœ… Successfully created version $new_version for $app_name in BundleCore"
              echo "   bcRegistryUrl: $bc_registry_url"
              echo "   registryUrl: $original_image"
              return 0
          }

          # â”€â”€ Main retag loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          echo ""
          echo "ðŸš€ Starting retag loop..."
          echo ""

          while IFS= read -r appdir; do
            [ -z "$appdir" ] && continue
            app=$(basename "$appdir")
            slug=$(echo "$app" | tr '[:upper:]' '[:lower:]')
            release_json="${appdir}release.json"

            if [ ! -f "$release_json" ]; then
              echo "No release.json for $app, skipping"
              continue
            fi

            images=$(jq -r '.images[]' "$release_json")
            for img in $images; do
                tag="${img##*:}"
                # remove everything after '--' (e.g. '1.21--h3a4d415_1' -> '1.21')
                tag="${tag%%--*}"
                dest="ghcr.io/${GHCR_ORG}/products/${PROD_DOMAIN}/${slug}:${tag}"
                if docker manifest inspect "$dest" > /dev/null 2>&1; then
                  echo "Image $dest already exists, skipping"
                  continue
                fi
                echo "Processing $img -> $dest"
                docker pull "$img"
                docker tag "$img" "$dest"
                docker push "$dest"
                cosign sign --yes "$dest"

                # Update BundleCore API with new version
                update_bundlecore_tool_version "$slug" "$tag" "$img" "$dest" || true
            done

            # Clean up local images after each tool to avoid disk bloat
            if docker images -q | grep -q .; then
              echo "Cleaning up docker images and cache..."
              docker images -q | xargs -r -n1 docker rmi -f || true
              docker builder prune -af || true
              docker image prune -af || true
              docker system prune -af --volumes || true
            fi
          done <<< "$TOOL_DIRS"
