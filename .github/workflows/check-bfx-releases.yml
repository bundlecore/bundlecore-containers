name: Check BFX Container Releases

on:
    schedule:
        - cron: '0 8 * * 0'  # Run at 8:00 AM UTC weekly (Sundays)
    workflow_dispatch:  # Allow manual trigger

jobs:
    check-and-update:
        runs-on: ubuntu-latest
        permissions:
          contents: write
          pull-requests: write
          
        steps:
            - name: Checkout repository
              uses: actions/checkout@v6
              with:
                token: ${{ secrets.GITHUB_TOKEN }}

            - name: Install required tools
              run: |
                sudo apt-get install -y jq curl
                gh auth login --with-token <<< "${{ secrets.GITHUB_TOKEN }}"

            - name: Check and process updates
              env:
                BCORE_AUTH_TOKEN: ${{ secrets.BCORE_AUTH_TOKEN_PROD }}
                GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                #!/bin/bash
                set -e # Exit on error

                # Configure git
                git config --global user.name 'github-actions'
                git config --global user.email 'github-actions@github.com'

                # Store the current branch name
                CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)

                check_quay_tags() {
                    local image_name=$1
                    curl -s "https://quay.io/api/v1/repository/${image_name}/tag/?limit=3&onlyActiveTags=true&orderBy=last_modified" || return 1
                }

                ## Function to push back the latest tag to bundlecore tool version
                update_bundlecore_tool_version() {
                    local app_name=$1
                    local new_version=$2
                    
                    ## before pushing, check if this version is already exists in bundlecore for this tool
                    ## If the PR is not accepted yet, it may cause duplicate version errors, so this check is necessary!
                    local versions_data=$(curl -sS -H "Authorization: Bearer ${BCORE_AUTH_TOKEN}" "https://bundlecore.com/api/tools/${app_name}/versions")
                    
                    if [ -z "$versions_data" ]; then
                        echo "Error: Failed to fetch versions for $app_name" >&2
                        return 1
                    fi
                    
                    # Extract existing versions and check if new version already exists
                    local existing_versions=$(echo "$versions_data" | jq -r '.data.versions[].version')
                    for ver in $existing_versions; do
                        if [[ "$ver" == "$new_version" ]]; then
                            echo "Version $new_version already exists for $app_name in BundleCore"
                            return 0
                        fi
                    done
                    
                    echo "Adding new version $new_version for $app_name in BundleCore"
                    
                    ## Extract the first version object as template
                    local template_body=$(echo "$versions_data" | jq '.data.versions[0]')
                    
                    if [ -z "$template_body" ] || [ "$template_body" == "null" ]; then
                        echo "Error: No existing versions found for $app_name to use as template" >&2
                        return 1
                    fi
                    
                    echo "Using template from version: $(echo "$template_body" | jq -r '.version')"
                    
                    ## Update the version, bcRegistryUrl, and registryUrl fields in the template
                    local updated_body=$(echo "$template_body" | jq \
                        --arg new_ver "$new_version" \
                        --arg bc_registry "ghcr.io/bundlecore/products/bfx/${app_name}:${new_version}" \
                        '.version = $new_ver | 
                        .bcRegistryUrl = $bc_registry |
                        .registryUrl = "quay.io/biocontainers/'"${app_name}"':'"${new_version}"'"')
                    
                    echo "Updated body: $updated_body"
                    
                    ## PUT the updated version back to BundleCore
                    response=$(curl -sS -w "%{http_code}" -o /tmp/curl_response -X POST -H "Authorization: Bearer ${BCORE_AUTH_TOKEN}" \
                        -H "Content-Type: application/json" \
                        -d "$updated_body" \
                        "https://bundlecore.com/api/tools/${app_name}/versions")

                    if [ "$response" -ne 200 ]; then
                        echo "Failed to update tool version for $app_name. HTTP status code: $response" >&2
                        echo "Response body: $(cat /tmp/curl_response)" >&2
                        return 1
                    fi

                    echo "✓ New version for $app_name to $new_version added successfully"
                    echo "✓ Set bcRegistryUrl to: ghcr.io/bundlecore/products/bfx/${app_name}:${new_version}"
                    return 0
                }
                check_git_source_tags() {
                    local app_name=$1
                    
                    if [[ -z "$BCORE_AUTH_TOKEN" ]]; then
                        echo "BCORE_AUTH_TOKEN is not set" >&2
                        return 1
                    fi
                    
                    local git_url=$(curl -sS -H "Authorization: Bearer $BCORE_AUTH_TOKEN" "https://bundlecore.com/api/tools/$app_name" | jq -r '.data.tool.codeRepo')
                    if [[ ! "$git_url" =~ ^https://github.com/ ]] && [[ ! "$git_url" =~ ^https://gitlab.com/ ]]; then
                        echo "Could not find Git URL for: $app_name" >&2
                        return 1
                    fi


                    # Find the latest tag from the Git repo
                    if [[ "$git_url" =~ ^https://github.com/ ]]; then
                        # Extract owner/repo from GitHub URL and strip trailing slash if present
                            local repo_path=${git_url#https://github.com/}
                            repo_path=${repo_path%.git}
                            repo_path=${repo_path%/}  
                        #  # Get the latest release tag from GitHub API and remove leading 'v' if present
                            latest_version=$(curl -sS  \
                            "https://api.github.com/repos/$repo_path/releases/latest" | jq -r '.tag_name'|sed 's/^v//')
                            
                            # if no releases found, fallback to latest tag
                            if [[ -z "$latest_version" || "$latest_version" == "null" ]]; then
                                ## Sometimes GitHub projects may not have releases, in that case use the following line instead
                                # Fallback to fetching the latest tag if no releases are found
                                latest_version=$(curl -sS "https://api.github.com/repos/$repo_path/tags" |jq -r '.[0].name' |sed 's/^v//')  
                            fi
                        
                    elif [[ "$git_url" =~ ^https://gitlab.com/ ]]; then
                        # Extract project path from GitLab URL
                        local project_path=${git_url#https://gitlab.com/}
                        project_path=${project_path%.git}
                        # URL encode the project path
                        local encoded_project_path=$(echo "$project_path" | sed 's/\//%2F/g')
                        # Get the latest release tag from GitLab API
                        latest_version=$(curl -sSL  \
                            "https://gitlab.com/api/v4/projects/$encoded_project_path/releases/permalink/latest" | jq -r '.tag_name'|sed 's/^v//') 

                        # if no releases found, fallback to latest tag
                        if  [[ -z "$latest_version" || "$latest_version" == "null" ]]; then
                            ## Sometimes GitLab projects may not have releases, in that case use the following line instead
                            # Fallback to fetching the latest tag if no releases are found
                            latest_version=$(curl -sSL "https://gitlab.com/api/v4/projects/$encoded_project_path/repository/tags" |jq -r '.[0].name' |sed 's/^v//')  
                        fi
                    else
                        echo "Unsupported Git provider $git_url for $app_name" >&2
                        return 1
                    fi
                    echo "$latest_version"
                    return 0                                                        

                }

                # Compare two semver strings: returns 0 if $1 >= $2, 1 otherwise
                version_gte() {
                    # Use sort -V (version sort) to determine order
                    local highest
                    highest=$(printf '%s\n' "$1" "$2" | sort -V | tail -n1)
                    [[ "$highest" == "$1" ]]
                }

                process_tool() {
                    local tool_path=$1
                    local tool_name=$(basename "$tool_path")
                    local release_file="$tool_path/release.json"

                    echo "Processing $tool_name..."

                    # Skip if release.json doesn't exist
                    if [[ ! -f "$release_file" ]]; then
                        return 0
                    fi

                    # Get repository name from release.json
                    local repo=$(jq -r '.images[0]' "$release_file" | cut -d':' -f1 | sed 's|quay.io/||')

                    # Extract current version from release.json (strip Bioconda build suffix, e.g. --pyhdfd78af_0)
                    local current_image_tag=$(jq -r '.images[0]' "$release_file" | cut -d':' -f2)
                    local current_version=$(echo "$current_image_tag" | sed 's/--.*$//')

                    # Get latest git tag
                    local latest_git_tag=$(check_git_source_tags "$tool_name")
                    if [[ -z "$latest_git_tag" || "$latest_git_tag" == "null" ]]; then
                        echo "Could not fetch latest git tag for $tool_name"
                        return 0
                    fi

                    echo "Latest git tag for $tool_name: $latest_git_tag"
                    echo "Current version in release.json for $tool_name: $current_version"

                    # Skip if the version we already have is >= the latest git tag.
                    # This prevents creating PRs when the git repo has an older release than
                    # what we already track (e.g. our release.json has 1.4.5, git tag is 1.4.4).
                    if version_gte "$current_version" "$latest_git_tag"; then
                        echo "Skipping $tool_name: current version ($current_version) is already >= latest git tag ($latest_git_tag)"
                        return 0
                    fi

                    # Check if git tag exists in release.json (exact match fallback)
                    if grep -q "$latest_git_tag" "$release_file"; then
                        echo "Latest git tag already exists in release.json for $tool_name"
                        return 0
                    fi

                    # Check Quay.io tags
                    local tags_data=$(check_quay_tags "$repo")
                    if [[ $? -eq 0 ]]; then
                        local quay_tags=$(echo "$tags_data" | jq -r '.tags | sort_by(.last_modified) | reverse | .[].name')
                        local matching_tag=""

                        while read -r tag; do
                            if [[ "$tag" =~ .*"$latest_git_tag".* ]]; then
                                matching_tag="$tag"
                                break
                            fi
                        done <<< "$quay_tags"

                        if [[ -n "$matching_tag" ]]; then
                            if grep -q "$matching_tag" "$release_file"; then
                                echo "Matching Quay tag already exists in release.json for $tool_name"
                                return 0
                            fi

                            # Create a new branch for this tool
                            local branch_name="update-$tool_name-$(date +%Y%m%d-%H%M%S)"
                            git checkout -b "$branch_name"

                            # Update release.json
                            local full_image="quay.io/${repo}:${matching_tag}"
                            local image_list=$(jq -r '.images' "$release_file")
                            image_list=$(jq --arg img "$full_image" '. |= [$img] + .' <<< "$image_list")
                            
                            echo "Updating $release_file with new version: $full_image"
                            jq --arg images "$image_list" '.images = ($images|fromjson)' "$release_file" > "$release_file.tmp"
                            mv "$release_file.tmp" "$release_file"

                            # Commit and push changes
                            git add "$release_file"
                            git commit -m "Update container version for $tool_name to $latest_git_tag"
                            git push origin "$branch_name"

                            # Create pull request using GitHub CLI
                            gh pr create \
                                --title "Update container version for $tool_name" \
                                --body "Updates the container version for $tool_name to match the latest Git release ($latest_git_tag)." \
                                --base main \
                                --head "$branch_name"
                            gh pr edit "$branch_name" --add-reviewer gkr0110,vipin-bc 2>/dev/null && echo "  ✓ Added reviewer gkr0110,vipin-bc" || echo "  ⚠ Could not add reviewer (missing permissions or reviewer may not exist)"
                            gh pr edit "$branch_name" --add-label "automated,new tool version" 2>/dev/null && echo "  ✓ Added labels automated,new tool version" || echo "  ⚠ Could not add labels (missing permissions or labels)"

                            # Return to original branch
                            git checkout "$CURRENT_BRANCH"
                            echo "Created PR for $tool_name"
                            
                            #call update_bundlecore_tool_version to add the new version to BundleCore
                            update_bundlecore_tool_version "$tool_name" "$latest_git_tag"
                            
                        else
                            echo "No matching Quay tag found for git tag $latest_git_tag"
                        fi
                    else
                        echo "Error fetching tags for $repo"
                    fi
                }

                # Process each tool directory
                for tool_dir in bfx/*; do
                    if [[ -d "$tool_dir" ]]; then
                        process_tool "$tool_dir"
                    fi
                done